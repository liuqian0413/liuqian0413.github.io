[{"title":"javascript 原型继承","date":"2018-03-27T11:16:19.000Z","path":"2018/03/27/javascript-原型继承与实例化/","text":"对于js继承一直都是半懂半不懂的状态，感觉需要整理一下：众所周知，全靠一种很奇特的”原型链”（prototype chain）模式，来实现继承。实例化众所周知，JavaScript里面所有的数据类型都是对象，我们需要一种机制，将所有的对象联系起来，因此，new命令引入了JavaScript，用来从原型对象生成一个实例对象。在JavaScript语言中，new命令后面跟的不是类，而是构造函数。距离来说JavaScript没有”子类”和”父类”的概念，也没有”类”（class）和”实例”（instance）的区分，","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS 作用域与闭包","date":"2018-03-27T06:52:43.000Z","path":"2018/03/27/JS-作用域与闭包/","text":"作用域在JavaScript中变量的作用域与其他语言不同，JavaScript的作用域不是由{}来界定，而是函数。所以循环实际上是在全局作用域中。12for(var i = 0; i &lt; 10; i++) &#123;&#125; console.log(i); // 10 全局变量&amp;局部变量JavaScript变量的作用域分为两种，局部和全局。在JavaScript中声明局部变量有两种方式，一种是在全局变量环境下使用var声明（显式声明的全局变量），另一种是在任何地方直接初始化变量，那么它也是全局变量（隐式声明的全局变量）。12345var name = 'Cherryl'; // 全局变量(显式）var age;function f1() &#123; age = '20'; // 还是全局变量（隐式）&#125; 隐式声明的全部变量和显式声明的全部变量的区别：隐式声明的全局变量可以删除，显式声明的全部变量就无法删除。因为通过var声明的式显式全局变量，其实际上是为window对象增加了一个不可配置的属性，而不加var声明的隐式全局变量，其实际上是为window对象增加了一个可以配置的属性。 影响：这样的设计，使得声明和赋值`很容易混淆，造成全局变量的滥用，使许多bug源头之一。 除了在任何地方直接初始化声明全局变量这一特殊之处外，JavaScript全局变量还可以在函数内部直接读取。12345var name = 'Cherryl';function f1() &#123; console.log(name);&#125;f1(); // 'Cherryl' 在函数中使用var定义的变量为局部变量。因为JavaScript的作用域是由函数界定，那么理所因当的函数外部是无法读取函数内部的局部变量。这一点其实其它的变成语言也是这样的。 1234function f1() &#123; var name = 'Cherryl';&#125;alert(name) // name is not defined 作用域链作用域链的原理和原型链很类似。在某个环境中为了读取变量时，会沿着作用域来搜索这个变量，从作用域的前端开始，向上级搜索。如果在当前局部环境中没有找到该变量，则继续沿作用域向上搜索，直到最顶层。搜索到该变量时将停止搜索，如果最后还是没有找到该变量，那么意味着这个变量是未定义的，即它的值为undefined。123456var a = 'a';function f1() &#123; var b = 'b'; console.log(a + b);&#125;f1() // 'ab' 在这个例子中，在全局环境中定义了全局变量a，然后在函数中定义了局部变量b。首先在当前的局部环境中搜索变量a的值，没有找到。那么继续向上一级搜索，在全局环境中找到标识符a的变量的值’a’。接着在全局环境中搜索变量b，得到局部变量b的值’b’。最后输出变量a和b的值拼接后的字符串的值。 闭包函数外部无法读取到函数内部定义的局部变量，所以当我们需要读取局部变量时据需要使用到闭包。 那么闭包是什么呢？我理解是函数返回一个局部作用域来使得函数外部能够读取函数内部的变量。因为JavaScript中作用域的界定是由函数来完成的，所以实际上也就是在函数中再返回一个函数。所以，在本质上，闭包就是将函数内部和外部连接起来的一座桥梁。 闭包的作用主要有两个：一个读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 一般情况下，当函数执行后，函数执行后，函数所在的局部环境将被销毁，也就是说函数在执行后函数中的变量是会被销毁的，在内存中就仅存在全局变量，即全局变量。 但是使用闭包的情况又有所不同，在函数内部定义的匿名函数会包含函数（外部函数）中的变量，在外部函数执行完毕后，原本应该被销毁的局部变量不会被销毁，因为闭包的作用域链仍然存在引用这些局部函数，内存的垃圾回收机制不会回收这部分变量所在的内存空间。直到匿名函数被销毁后，这些局部对象才会被销毁。 123456789101112 function f1()&#123; var n=999; nAdd = function()&#123;n+=1&#125;; function f2() &#123; alert(n) &#125;return f2 &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 内存泄漏由于闭包使得函数中的局部变量不会被垃圾回收机制回收，会依然存在于内存中，所以使用闭包的内存消耗很大，所以大量的使用闭包会造成性能问题，另外，在IE中可能会导致内存泄漏。解决方法是在退出函数前将不使用的局部变量全部删除。 12345678910function f1() &#123; var e = document.getElementById('id'); var id = e.id; e.onclick = function() &#123; alert(id); &#125; e = null; // 删除不使用的局部变量值，只将需要的 id 保存为副本&#125; 改变父函数内部变量的值闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的私有属性(private value)，这时一定要当心，不要随便改变父函数内部变量的值。 参考： 作用域与闭包-Ahonn 学习Javascript闭包-阮一峰","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"hexo的Bluelake主题添加打赏功能","date":"2018-03-26T08:37:16.000Z","path":"2018/03/26/hexo的BlueLake主题添加打赏功能/","text":"打赏是读者对笔者支持的最大动力，作为经常写博客的笔者来说，打赏功能如果在自己的博客中出现，那真的是求之不得呀（虽然基本不会有人来打赏）！然而BlueLake这一主题并没有附加打赏的功能，所以我就自己做一个来玩玩了. 最终效果如下： 1、准备支付宝和微信二维码图片 微信生成二维码教程地址 支付宝生成二维码地址 如果想要追求好看有趣的二维码，可以使用在线二维码美化器 2、编写打赏模块的代码在主题的_partial文件夹下(我的目录为themes/BlueLake/layout/_partial)新增donate.jade文件，内容如下：12345678910111213141516.post-donate #donate_board.donate_bar.center a#btn_donate.btn_donate(href='javascript:;', title='打赏') .donate_txt | &amp;uarr; br != theme.donate.message br #donate_guide.donate_bar.center.hidden.pay img(src=theme.donate.wechatpay, title='微信打赏' alt= '微信打赏') img(src=theme.donate.alipay, title='支付宝打赏' alt= '支付宝打赏') script(type='text/javascript'). document.getElementById('btn_donate').onclick = function()&#123; $('#donate_board').addClass('hidden'); $('#donate_guide').removeClass('hidden'); &#125; 3、增加css文件在主题的css文件夹下（我的目录为themes/BlueLake/source/css）增加donate.styl文件，内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.donate_bar &#123; text-align: center; margin-top: 5%&#125;.pay&#123; display: flex justify-content: space-between&#125;.donate_bar a.btn_donate &#123; display: inline-block; width: 82px; height: 82px; margin-left: auto; margin-right: auto; background: url(http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif)no-repeat; -webkit-transition: background 0s; -moz-transition: background 0s; -o-transition: background 0s; -ms-transition: background 0s; transition: background 0s&#125;.donate_bar a.btn_donate:hover &#123; background-position: 0 -82px&#125;.donate_bar .donate_txt &#123; display: block; color: #5b5b5b; font: 14px/2 \"Microsoft Yahei\"&#125;.donate_bar.hidden&#123; display: none&#125;.post-donate&#123; margin-top: 80px;&#125;#donate_guide&#123; height: 210px; width: 420px; margin: 0 auto;&#125;#donate_guide img&#123; height: 200px; height: 200px;&#125; 4、在base.jade文件中引用css文件在文件themes/maupassant/layout/base.jade的head部分引用donate.styl文件：1link(rel='stylesheet', type='text/css', href=url_for(theme.css) + '/donate.css') 5、在post.jade中加入打赏功能准备工作已经完成，现在可以在themes/BlueLake/layout/post.jade文件中想要显示打赏功能的位置加上如下代码123if theme.donate.enabled == true script(type='text/javascript', src=url_for(theme.js) + '/jquery.js' + '?v=' + theme.version, async) include _partial/donate 这个代码是基于jquery的，所以记得在themes/BlueLake/source/js中引入jquery.js 6、在_config.yml中启用打赏功能在主题_config.yml文件中配置了是否启用打赏功能的配置项，如果配置为true，则启用打赏功能，否则禁止打赏，配置如下：12345donate: enabled: true message: 坚持原创技术分享，您的支持将鼓励我继续创作！ wechatpay: /images/weChatMoney.png alipay: /images/alipayMoney.png 可以发现，在donate.jade文件中也用到了以上配置，message表示打赏标题，wechatpay和alipay分别表示微信/支付宝收款二维码。到这里，一个打赏的功能就实现了！","tags":[]},{"title":"https 和 http 的区别","date":"2018-03-26T02:52:20.000Z","path":"2018/03/26/https-和-http-的区别/","text":"在详细探究HTTP与HTTPS之前，先理清一下HTTP的基本概念： HTTP中文叫做超文本传输协议,是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 在这里，我们需要先提出几个问题：为什么需要使用HTTPS来进行通信？HTTPS在安全上做了哪些事情？ HTTP的特点 HTTP是无连接的：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态的：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP的缺点 容易被监听http通信都是明文，即未加密，内容可能会被窃听。窃听可能发生在互联网通信中的各个环节。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的。 被伪装通信双方的身份没有进行验证，可能出现伪装身份的情况。所有人都可以对服务器发起请求。比如你请求 www.taobao.com ,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。 可以看出，对于客户端来说，无法确定这台Web服务器是否是“真的”服务器，可能通过了伪装。对于服务器来说，也无法确定自己返回的报文是否被真正的客户端接收到。此外，服务器的全盘接收的缺点也会被利用来进行DOS攻击。因此，以客户端为例，客户端在与服务器通信之前需要确定服务器的身份，该身份即是一份证书，该证书有值得信赖的第三方颁发，客户端确认身份后才进行通信。 被篡改接受的报文完整性无法确定，可能中途被改动。hacker中间篡改数据后，接收方并不知道数据已经被更改.我们知道，服务器接收到请求后，会进行响应。但服务器和客户端都无法知道报文中途的传输是否出现了问题。很有可能在传输时被其他攻击者进行了篡改，报文完整性遭到破坏。虽然HTTP提供了确认报文完整性的方法（MD5,SHA-1），但是也无法完全保证报文的完整性。因为MD5本身也可能被攻击者改写。在SSL中，提供了认证和加密处理等功能。通过配合SSL可以达到保证报文完整性的目的。 HTTPS与HTTP协议的差异 HTTP的URL是以“http://”开始，HTTPS的URL是以“https://”开始； HTTP默认端口为80，HTTPS的默认端口为443； 采用HTTPS的Web Server需要到CA申请证书； HTTPS由HTTP+SSL来实现，可进行加密传输、身份认证等，要比HTTP安全 HTTP的信息是明文传输，而HTTPS的信息是加密传输 HTTPS解决的问题：鉴于HTTP的缺点，HTTPS在HTTP的基础上增加了： 通信加密 证书认证 完整性保护 https很好的解决了http的三个缺点（被监听、被篡改、被伪装）https不是一种新的协议，它是http+SSL(TLS)的结合体，SSL是一种独立协议，所以其它协议比如smtp等也可以跟ssl结合。https改变了通信方式，它由以前的http—–&gt;tcp，改为http——&gt;SSL—–&gt;tcp；https采用了共享密钥加密+公开密钥加密的方式 防监听数据是加密的，所以监听得到的数据是密文，hacker看不懂。 防伪装伪装分为客户端伪装和服务器伪装，通信双方携带证书，证书相当于身份证，有证书就认为合法，没有证书就认为非法，证书由第三方颁布，很难伪造 防篡改https对数据做了摘要，篡改数据会被感知到。hacker即使从中改了数据也白搭。 普遍的加密方式共享密钥加密（对称密钥）顾名思义，就是客户端和服务器都拥有一把相同的钥匙，对报文的加密和解密用的都是这把钥匙，而且密钥也需要在通信的过程中发给对方，对方才能通过这把钥匙来解密。因此，一旦在通信过程中，这把密钥被攻击者获取，报文加密便失去了意义。 公开密钥加密共享密钥带来了一个问题就是，如何能够安全地把密钥发送给对方。而公开密钥则较好地解决了这个问题。公开密钥加密使用得是非对称的密钥。一把是公有密钥，一把是私有密钥。公有密钥是对通信双方公开的，任何人都可以获取，而私有的则不公开。发送方使用这把公有密钥对报文进行加密，接收方则使用私有的密钥进行解密。仅仅通过密文和公有密钥是很难破解到密文。使用公开密钥带来安全的同时，也隐藏着一些问题，就是如何保证公开的这把公有密钥的真实性？这个问题伴随也是证书机构。通过证书来保证公有密钥的真实性。 HTTPS采用混合加密机制由于公有密钥的机制相对复杂，导致其处理速度相对较慢。于是HTTPS利用了两者的优势，采用了混合加密的机制。我们知道，共享（对称）密钥未能解决的问题是如何能够安全地把密钥发送给对方。只要解决了这个问题就可以进行安全地通信。于是，HTTPS首先是通过公有密钥来对共享密钥进行加密传输。当共享密钥安全地传输给对方后，双方则使用共享密钥的方式来加密报文，以此来提高传输的效率。 HTTPS的握手机制(建立连接的过程) 步骤1：向服务器发起请求。 步骤2-3：取出公有密钥及证书并发送给客户端。 步骤4：客户端判断公有密钥是否有效，无效则显示警告。有效则生成一个随机数串，并以此生成客户端的共享密钥。 步骤5：用步骤3得到的公有密钥对该随机数串加密，发送到服务器。 步骤6：服务器得到加密报文，用私有密钥解密报文，得到随机数串，并以此生成服务器端的共享密钥。此时客户端和服务端拥有相同的共享密钥，可以用该共享密钥进行安全通信。 步骤7-8：服务器对响应进行加密，客户端对报文进行解密。 选择HTTP还是HTTPS来搭建服务器在比较之前，首先要了解HTTPS存在的问题才能进行权衡。 SSL会使通信的效率降低 通信速率降低HTTPS 除了TCP连接，发送请求，响应之外，还需要进行SSL通信。整体通信信息量增加。 加密过程消耗资源每个报文都需要进行加密和解密的运算处理。比起HTTP会消耗更多的服务器资源。 证书开销如果想要通过HTTPS进行通信，就必须向认证机构购买证书。基于以上三点，如果通信中传输的是非敏感的信息，则会较多地选择HTTP协议。而当通信过程中会涉及个人隐私或其他安全信息时，则会选择用HTTPS。当然，访问量也是考虑的因素之一，如果访问量很大，而每个报文都进行加密解密，也会给服务器带来很大的负担。 参考：深入分析HTTP与HTTPS","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"Hexo搭建博客进阶","date":"2018-03-26T01:51:44.000Z","path":"2018/03/26/Hexo搭建博客进阶/","text":"本文主要讲解如何安装一个好看的hexo主题和讲讲那些我爬过的坑。 一、安装主题我选的是BlueLake这款主题。 可以直接到BlueLake发布页进行配置，相关的配置说明上面都写的非常详细。 安装主题和渲染123$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 启用在Hexo配置文件（hexo/_config.yml）中把主题设置修改为BlueLake。1theme: BlueLake 后面的我就不赘述了，大家参照页面文档进行一步步的配置就好 二、部署时保证README.md文件不被渲染想要写一个README.md文件并更新到github上，却不料每次上传到github后README.md还是会不见。原因是本地的是博客源代码，GitHub上面的是博客生成代码。README.md文件每次更新到github上时都会被解析成.html文件。 其实确保README.md文件不被渲染也挺容易的，只要在博客根目录下的配置文件_config.yml中配置一下”skip_render”选项就行了，将不需要渲染的文件名称加入的其选项下就行了。skip_render: README.md 并将README.md文件放在source下面,就可以保证README.md文件不被渲染啦。 三、webstorm中markdown语法高亮个人最常使用的web编辑器是webstrom，然而webstorm默认是无法高亮md文件的。这个时候我们需要进行简单的配置。 步骤1、打开webstorm，File–&gt;Setting–&gt;输入plugin–&gt;Install JetBrains plugin…–&gt;输入markdown–&gt;点击右边的“Install”,安装完，重启webstorm。 2、新建test.md，然后编辑，如果没有效果的话。File–&gt;Setting–&gt;输入file type–&gt;找到Markdown–&gt;在下面的Registers Patterns添加上*.md。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Mac OS上使用Hexo+github搭建自己的博客","date":"2018-03-25T14:35:17.000Z","path":"2018/03/25/Mac OS上使用Hexo+github搭建自己的博客/","text":"很久以前就想搭建一个个人博客了，之前在公司实习的时候用过Jekyll搭建一个”播客”，最近找实习，偶尔看到东西会做点笔记，所以想着自己搭建一个个人博客，Jekyll其实和Hexo类似，都可以用来搭建播客，目前看到关于Hexo的资源比较多，所以决定使用Hexo来搭建。用下来个人觉得Hexo确实会比jekyll好用很多。作为一个年少无为，买不起服务器，买不起域名的穷low程序媛，就想着使用Hexo搭建一个个人博客，并关联到GitHub上，节省域名费用。欢迎大家在评论区留言，带我装逼带我飞。PS:因本人用的是苹果机，所以本教程以MACOS为参考，但mac与windows搭建的方法步骤其实相差无几。主要参考文章使用Hexo+Github一步步搭建属于自己的博客（基础） 相关步骤1、安装node.js和配置好node.js环境，这里不详细说，推荐使用homebrew安装。请参考node.js在mac上环境安装与测试.成功界面如下： 2、安装git和配置好git环境，这里我也是用homebrew直接安装的。成功界面如下： 3、安装Hexo，在自己认为合适的地方创一个新文件夹，用来保存博客的相关项目代码。输入npm install hexo –g,开始安装Hexo。（我这样直接安装的时候发生了个错误，提示没有权限，所以我在前面又加了一个sudo）。输入hexo-v，检查hexo是否安装成功。输入hexo init，初始化该文件看到Start blogging with Hexo！初始化完成！输入npm install ，安装所需要的组件。输入hexo g ，首次体验hexo。输入hexo s ,开启服务器，访问该网址，正式体验hexo（加入页面一直无法跳转，那么端口可能被占用了，此时我们ctrl+c停止服务器，接着输入”hexo server –p 端口号”来改变端口号）出现下图就成功了！ 4、Github账户注册和新建项目项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README。(这里我第一次的时候账户名写错了，导致后来本地的样式和github显示的不一致，后来我将下图中的myBlog改为我的账户名liuqian0413就显示正常了。大家记住一定不要写错了！)在建立好的项目右上方有个setting按钮，点击，向下拉到Github Pages，你会看到该项目已经被部署到网络上，能够用外网来访问它。（如果没有出现地址，将souce那一栏的第一个参数选为master branch，然后点击save后就会刷新出来） 5、将Hexo与Github Page联系起来输入cd ~/.ssh，检查是否有.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 如果没有找到该文件，输入ssh-keygen -t rsa -C &quot;784575932@.com &quot;（这里的邮箱填写你注册GitHub时候自己的邮箱）,连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub 接着输入eval &quot;$(ssh-agent -s)&quot;，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent. 接着登录Github，点击头像下的settings，添加ssh 复制id_rsa.pub文件里面的内容，我们可以使用vim id_rsa.pub查看 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决首先，清除所有的key-pair:ssh-add -Drm -r ~/.ssh删除你在GitHub中的public-key重新生成ssh密钥对ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;接下来正常操作：在GitHub上添加公钥public-key:1.首先在你的终端运行xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2.在github上添加公钥时，直接复制即可3.保存测试：在终端ssh -T git@github.com 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh(右下角) 6、新建博客并发布新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件: 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","date":"2018-03-25T13:13:48.372Z","path":"2018/03/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]