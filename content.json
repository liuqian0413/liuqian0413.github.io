[{"title":"原生js实现Ajax","date":"2018-04-22T03:58:24.000Z","path":"2018/04/22/原生js实现Ajax/","text":"Ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步刷新。这意味着可以在不重新加载整个网页的情况下，对网页的某个部分进行更新。 五步创建法 创建XMLHttpRequest对象 使用open方法设置和服务器的交换信息 设置发送的数据，开始和服务器端交互 注册事件 更新界面 get请求 1234567891011121314//步骤一：创建异步对象var ajax = new XMLHttpRequest();//步骤二：设置请求的类型和url参数，参数一是请求的类型，参数二是请求的url，可以带参数，动态的传递参数myName到服务端ajax.open('get','getName.php?myName='+name);//步骤三：发送请求ajax.send();//步骤四：注册事件onreadystatechange状态改变就会调用ajax.onreadystatechange = function()&#123; if (ajax.readyState ==4 &amp;&amp; ajax.status == 200)&#123; //步骤五：如果能够进入这个状态，说明数据完美的回来了，并且请求的页面是存在的 console.log(ajax.responseText) &#125; &#125; post请求 12345678910111213//步骤一：创建一个异步对象var xhr = new XMLHttpRequest()//步骤二：设置请求的类型和url参数，post请求一定要添加请求头才行，不然会报错xhr.open('post','getName.php')xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");//步骤三：发送请求xhr.send('name = fox&amp;age = 18')//步骤四：注册事件xhr.onreadystatechange = function()&#123; if(xhr.readyState==4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText) &#125;&#125; 将get请求和post请求封装为了方便使用，我们可以将它们封装进方法里面，要用的时候，直接调用就好了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ajax(&#123; url:\"getName.php\", type:\"POST\", data:&#123;name:\"fox\",age:20&#125;, dataType:\"json\", success:function(response,xml)&#123; //此处放成功后执行的代码 &#125;, fail:function(status)&#123; //此处放失败后执行的代码 &#125;&#125;);//开始封装function ajax(options)&#123; //获取所有参数 options = options || &#123;&#125;; options.type = (options.type || 'GET').toUpperCase(); options.dataType = options.dataType||\"json\"; var params = formatParams(options.data); //创建异步对象 var xhr = new XMLHttpRequest(); //获取请求类型并发送 if(options.type = \"GET\")&#123; xhr.open('GET',options.url+'?'+params,true) xhr.send() &#125;else&#123; xhr.oprn('post',options.url,true); xhr.send(params) &#125; //注册事件 xhr.onreadystatechange = function()&#123; if(xhr.readyState==4 &amp;&amp; xhr.status ==200)&#123; options.success &amp;&amp; options.success(xhr.responseText) &#125;else&#123; options.fail &amp;&amp; options.fail(status) &#125; &#125;&#125; //格式化参数function formatParams(data)&#123; var arr = []; for(var name in data)&#123; arr.push(encodeURIComponent(name)+\"=\"+encodeURIComponent(data[name])); &#125;; arr.push((\"v=\"+Math.random()).replace(\".\")); return arr.join(\"&amp;\")&#125;","tags":[]},{"title":"ES6语法(5)——Promise用法","date":"2018-04-22T03:54:18.000Z","path":"2018/04/22/ES6-语法(5)——Promise用法/","text":"","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6语法(4)——数组的扩展","date":"2018-04-22T03:03:15.000Z","path":"2018/04/22/ES6-语法(4)——数组的扩展/","text":"数组的扩展 ##… 扩展运算符是…，好比rest参数的逆运算，讲一个数组转化为用逗号分割的参数序列。1234console.log(...[1,2,3]);//1,2,3console.log(1...[1,2,3],5);//1,2,3,4,5 用于函数调用1234567891011121314151617181920212223function push(array,items)&#123; array.push(...items);&#125;function add(x,y)&#123; return x+y&#125;const numbers = [3,38];add(...numbers); //41``` ## 应用复制数组```javascript//es5const a1 = [1,2];const a2 = a1.contact();//es6const a1 = [1,2];//写法一const a2 = [...a1];//写法二const [...a2] = a1; 将字符串转化为数组12[...\"hello\"]//[\"h\",\"e\",\"l\",\"l\",\"o\"] Array.from()Array.from()方法用于将两类对象转为真正的数组：类似数组的对象(array-like object)和可遍历(iterable)的对象（包括ES6新增的数据结构Set和Map）。 12345678//数组去重var array = [1,2,1,1,\"1\"];function unique(array)&#123; return Array.from(new Set(array));&#125;console.log(unique(array)); [1,2,\"1\"] 数组实例的includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串includes方法类似。ES2016引入该方法。 123[1,2,3].includes(2) //true[1,2,3].includes(4) //false[1,2,NaN].includes(NaN) //true","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6语法(3)——变量的解构赋值","date":"2018-04-21T15:07:15.000Z","path":"2018/04/21/ES6-语法(3)——变量的解构赋值/","text":"变量的解构赋值ES允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destrucuring) 基本用法1、数组的解构赋值。情况一： 模式匹配：只要等号两边的模式相同，左边的变量就会被赋予相应的值。 123456 //es5 let a = 1; let b = 2; let c = 3; //es6let [a,b,c] = [1,2,3]; 情况二：不完全解构：即左边的模式，只匹配一部分等号右边的数组。这种情况，解构依然可以成功。反过来则不行，元素值为undefined1234567let [a,b] = [1,2,3]//a:1//b:2let[a,[b],c] = [1,[2,3],4]//a:1//b:2//c:4 情况三：等号的右边不是数组，那么将会报错1234567//都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个），要么本身就不具备Iterator接口（最后一个表达式）let [foo] = 1;let [foo] = falselet [foo] = NaN;let [foo] = undefined;let [foo] = nulllet [foo] = &#123;&#125; 情况四：默认值：解构赋值允许指定默认值,注意，ES6内部严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined ,默认值才会生效。12345let [foo = true] = [];foo //truelet [x,y='b'] = ['a'] //x='a',y = 'b'let [x,y='b'] = ['a',undefined] //x='a',y = 'b'let [x= 1] = [null] 2、对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。12345let &#123;bar,foo&#125; = &#123;foo:\"aaa\",bar:\"bbb\"&#125;bar //\"bbb\"foo //\"aaa\"let &#123;paa&#125; = &#123;foo:\"aaa\",bar:\"bbb\"&#125;paa //undefined 3、字符串的解构赋值字符串也可以解构赋值，这是因为此时，字符串转换成了一个类似于数组的对象。123const [a,b,c,d,e] = \"hello\"a //\"h\"b //\"e\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值12let &#123;length:len&#125; = 'hello'len //5 4、数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则先会转为对象。12345//数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。let &#123;toString :s&#125; = 123s === Number.prototype.toString //truelet &#123;toString :s&#125; = trues === Number.prototype.toString //true 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象，由于undefined和null无法转为对象，所以对他们进行解构赋值，都会报错。12let &#123;prop:x&#125; = undefined //TypeErrorlet &#123;prop:y&#125; = null //TypeError 4、函数参数的解构赋值函数的参数也可以使用解构赋值 1234567function add([x,y])&#123; return x+y&#125;add([1,2]) //3[[1,2],[3,4]].map(([a,b]) =&gt; a+b);//[3,7] 函数参数的解构也可以使用默认值。 用途 交换变量的值：[x,y] = [y,x] 从函数返回多个值： return [a,b,c] 函数参数的定义： f([1,2,3]) 提取json数据： let {errCode,errText} = {errCode:’200’,errText:’success’}","tags":[]},{"title":"ES6语法(2)——箭头函数和普通函数的区别","date":"2018-04-21T14:49:00.000Z","path":"2018/04/21/ES6-语法(2)——箭头函数和普通函数的区别/","text":"箭头函数和普通函数的区别 1、箭头函数不绑定this，会捕获其所在的上下文的值(继承外围作用域的this)，作为自己的this。12345678910111213141516171819var obj = &#123; a:10, b:() =&gt; &#123; console.log(this.a) //undefined console.log(this) //window &#125;, c:function()&#123; return () =&gt; &#123; console.log(this.a) //10 &#125; &#125;, d:function()&#123; console.log(this.a) //10 console.log(this) //f &#125; &#125; obj.b(); obj.c()(); obj.d() 2、箭头函数在定义之后，this就不会发生改变了。通过call()或apply()方法调用一个函数时，只是传入了参数而异，对this并没有什么影响。123456789var obj = &#123; a:10, b:function(n)&#123; var f = (v)=&gt; v + this.a var c = &#123;a:20&#125;; return f.call(c,n) &#125; &#125; console.log(obj.b(1)) //11 3、不可以当作构造函数，也就是说，不可以new命令，否则会抛出一个错误。1234let Fun =()=&gt;&#123; console.log('111') &#125; let f = new Fun() //TypeError:Fun is not a constructor 4、不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。12345678910111213function A()&#123; console.log(arguments) &#125; var B = (b) =&gt; &#123; console.log(arguments) &#125; let C = (...c) =&gt; &#123; //..c即为rest的参数 console.log(c) &#125; A(2) //Arguments[2, callee: ƒ, Symbol(Symbol.iterator): ƒ] B(2) //ReferenceError:arguments is not defined C(2) //[2] 5、不可以使用yield命令，因此箭头函数不能用做Generator函数。6、箭头函数没有原型属性12345678var a = () =&gt; &#123; return 1 &#125; function b()&#123; return 2; &#125; console.log(a.prototype) //undefined console.log(b.prototype) // &#123;constructor:f&#125; 7、箭头函数不能换行12var a = () =&gt;1; //SyntaxError:Unexpectede token =&gt; 箭头函数后面的大括号注意： 箭头函数后面不加大括号，默认只能有一行代码，默认return； 箭头函数后面加大括号，默认没有return 123456789let res1 = (r1,r2) =&gt; r1+r2;let res2 = (r1,r2) =&gt; &#123;r1+r2&#125;;let res3 = (r1,r2) =&gt; &#123;return (r1+r2)&#125;let r1 = res1(1,2)let r2 = res2(1,2)let r3 = res3(1,2)console.log(r1) //3console.log(r2) //undefinedconsole.log(r3) //3 打印出来发现r1,r3正确，r2为undefined","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6语法(1)——let和const","date":"2018-04-11T02:35:47.000Z","path":"2018/04/11/ES6-语法(1)——let和const/","text":"1、let和const命令特点let命令特点： 不存在变量提升。let声明的变量，只在let命令所在的代码块内有效。 会出现暂时性死区。只要块级作用域内存在let命令，它所声明的变量就”绑定”（binding）这个区域，不再受外部的影响。 不允许重复声明。let不允许在相同作用域内，重复声明同一个变量。因此，不能再函数内部重新声明参数。 const命令特点： 声明一个只读的常量。一旦声明，常量的值就不能改变。且一旦声明变量，就必须立即初始化，不能留到以后赋值。 作用域与let命令相同：只在声明所在的块级作用域内有效。 也不存在变量提升。只能在声明的位置后面使用。 也会出现暂时性死区。 也不允许重复声明。 2、let基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。for循环的计数器，就很适合使用let命令1234for(var i = 0;i&lt;3;i++)&#123;&#125;for(let j = 0;j&lt;3;j++)&#123;&#125;console.log(i) //3console.log(j) //RefernceError 上面代码中，使用var声明的计数器i，在全局范围内都有效，最后输出是3。而使用let声明的计数器j只在for循环体内有效，在循环体外引用就会报错。 此外，for循环还有一个特别指出，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for(let i = 0;i&lt;3;i++)&#123; let i = 'abc' console.log(i) //abc //abc //abc&#125; 上面代码正确运行，输出了三次abc。这表明函数内部的变量i与循环变量i在不同的一个作用域，有各自单独的作用域。 不存在变量提升var 命令会发生”变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了愈发行为，它所声明的变量一定要在声明后使用，否则报错。 1234console.log(foo) //undefinedvar foo = 2;console.log(bar) //ReferenceErrorlet bar = 3 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不回发生变量提升。这表示在它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就是绑定(binding)这个区域，不再受外部的影响。12345if (true)&#123; tmp = 'abc'; let tmp; console.log(tmp)&#125; 上面代码中，存在全局变量tmp,但是块级作用域内let又声明了一个局部变量tmp,导致后者绑定这个块级作用域，所以在let声明前，对tmp赋值会报错。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡事在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，成为”暂时性死区”(temporal dead zone,简称TDZ) 123456789tmp = 'abc'console.log(tmp); //ReferenceErrorlet tmp;console.log(tmp); //undefinedlet tmp;tmp = 123;console.log(tmp); //123 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的”死区”。 “暂时性死区”也意味着typeof不再是一个百分百安全的操作。 12typeof x; //ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的死区，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError 作为比较，如果一个变量根本没有声明，使用typeof 反而不会报错。1typeof y; //undefined 另外，下面的代码也会报错，与var行为不同。 12345//不报错var x = x//报错let y = y 上面代码报错，也是因为暂时性死区。适应let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前就去取x的值，导致报错’x未定义’。ES6 规定暂时性死区let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质是，只要已进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到变量声明的哪一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。123456789101112131415//不报错function func()&#123; var a = 10; var a = 1;&#125;//报错function func()&#123; let a = 10; var a = 1;&#125;//报错function func()&#123; let b = 10; let b = 1;&#125; 因此，不能在函数内部重新声明变量参数。 3、块级作用域为什么需要块级作用域？ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。1234567function f()&#123; console.log(tmp); if(false)&#123; var tmp = 'hello' &#125;&#125;f() //undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。1234for (var i = 0;i&lt;5;i++)&#123; console.log(i)&#125;console.log(i)//5 上面代码中，变量i只用来控制循环，但是循环技术后，它并没有消失，泄露成了全局变量。 ES6的块级作用域let实际上为JavaScript新增了块级作用域。 12345678function f1()&#123; let n = 5; if(true)&#123; let n = 10 &#125; console.log(n) //5&#125;f1() 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。 ES6 允许块级作用域的任意嵌套。块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。12345678910//IIFE写法(function()&#123; var tmp = 3 console.log(tmp)//3&#125;())//块级作用域写法&#123; let tmp = 5 console.log(tmp)//5&#125; 块级作用域与函数声明ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 4、const基本用法const声明一个只读的敞亮。一旦声明，常量的值就不能改变。1234const PI = 3.14console.log(PI)PI = 3 //TypeError 上面的代码表明改变常量的值会报错。 const声明的变量不能改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。1const PI //Uncaught SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不复制，就会报错。 const的作用域与let命令相同：还在声明所在的块级作用域内有效。 1234if(true)&#123; const PI = 3.14&#125;PI //Uncaught ReferenceError: PI is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 ES6声明变量的六种方法 ES5只有两种声明变量的方法：var命令和function命令。 ES6有六种声明变量的方法：var,function,let,const,import ,class 新数据类型：SymbolES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：undefined、null、布尔值 (Boolean)、字符串(String)、数值(Number)、对象(Object)。 Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡事属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 123let s = Symbol()typeof s//\"Symbol\" Promise更详细的介绍Promise Promise对象有以下两个特点。（1）对象的状态不受外界印象，Promise对象代表一个异步操作，有三种状态：pending（进行中）、 fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是”承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会在变，任何时候都可以得到这个结果，Promise对象的状态该拜年，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就铃鼓了，不会再变了，会一直保持这个结果。这与事件（event）不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 1234567const promise = new Promise(function(resolve,reject)&#123; if (/*异步操作成功*/)&#123; resolved(value) &#125;else&#123; reject(error); &#125;&#125;); generator更详细的介绍[generator] Generator函数是ES6提供的一种异步变成解决方案，语法行为与传统函数完全不同。Generator函数有多种理解角度。语法上，首先可以把它理解成是一个状态机，封装了多个内部状态。 执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象，可以依次遍历Generator函数内部的每一个状态。 形式上，Generator函数是一个普通函数，但是有两个特征。意识，function关键字与函数名之间有一个星号*；二是，函数体内使用yield表达式，定义不同的内部变量（yield在英语里的意思就是”产出”）。 yield表达式是暂停执行的标记，而next方法可以恢复执行。 1234567891011121314function* helloGenerator()&#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()//&#123;value:'hello',done:false&#125;hw.next()//&#123;value:'world',done:false&#125;hw.next()//&#123;value:'ending',done:true&#125;hw.next()//&#123;value: undefined,done:true&#125; 总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针，以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"apply()、call()和bind()的原理和区别","date":"2018-04-01T12:07:18.000Z","path":"2018/04/01/apply-、call-和bind-的原理和区别/","text":"最近看到很多面试题中都提到了apply(),call()和bind()，遂搞清楚了记录下。 1、基本作用：改变对象的执行上下文。 什么是执行上下文我们在写一个方法的时候，总是会用到一个关键字this，而this的指向就是我们这里所说的执行上下文（执行环境） 为什么需要改变执行上下文？小明有一个炒菜的铲子，小明的室友小刚今天突然想自己做菜吃，但是小刚没有铲子。小刚又不想为了做个菜单独买把铲子，于是就借用了小明的铲子，这样既达到了目的，又节省了开支，一举两得 改变执行上下文也是一样，A对象有一个方法，而B对象因为某种不可言说的情况也需要用到一样的方法，那么这时候我们是单独为B扩展个方法呢，还是借用一下A的方法呢？当然是借用A的啦，既完成了需求，又减少了内存的占用. 2、call()和apply()每个函数都有两个非继承的方法。call()和apply()。call()和apply()都属于Function.prototype的一个方法，他是JavaScript引擎内在实现的，因为属于Function.prototype，所以每个Function对象实例，都有call(),apply()属性。其实他们的作用是一样的，只是传递的参数不一样而已。 call()：接收两个参数，第一个参数指定了函数体内this对象的指向，后面的参数是函数调用时的参数按顺序传递。 apply()：接收两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为数组或者一个类数组。apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入。 举个例子： 1234567891011let obj1 = &#123; name: \"cherryl\", getName: function()&#123; return this.name; &#125;&#125;let obj2 = &#123; name: 'liuqian'&#125;console.log(obj1.getName()); // \"cherryl\"console.log(obj1.getName.call(obj2)); // \"liuqian\" 12345function showArgs(a, b, c)&#123; console.log(a,b,c);&#125;showArgs.call(this, 3,4,5); // \"3 4 5\"showArgs.apply(this, [5,6,7]); // \"5 ,6,7\" 面试题：定义一个 log 方法，让它可以代理 console.log 方法：1234567891011121314151617181920function log(msg)&#123; console.log(msg);&#125;log(12); //12log(1,2); //1//上面能够基本解决打印输入问题，但是下面多参数的时候就gg了。换个更好的方式吧。//去面试的时候，面试官问我怎么使用传进去的参数，我说直接使用，他说不对，是通过一个arguments数组function log()&#123; console.log.apply(console,arguments);&#125;log(12); //12log(1,2) //1 2////接下来是要在每一条打印信息前面都要加上一个特定字符串'Error'又怎么说呢？function log()&#123; let args = Array.prototype.slice.call(arguments);//将类数组转化为数组 args.unshift(\"Error\") console.log(console,args);&#125;log(12)log(1,2) 3、bind()bind方法与apply和call很相似，也是可以改变函数体内this的指向。 MDN的解释是：bind()方法回创建一个新函数，称为绑定函数，党调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 举个例子：12345678910var func = function()&#123; console.log(this.x); console.log(arguments);&#125;func()var obj = &#123; x:2&#125;var bar = func.bind(obj,1)bar() //2 , &#123;'0':1&#125; 注意，在JavaScript中，多次bind()是无效的。更深层次的原因呢，bind()的实现，相当于使用函数在内部包了一个call/apply,第二次bind()相当于再包住一次bind()，故第二次以后的bind()是无法生效的。 4、这三个方法的异同举个例子：123456789101112var obj = &#123;x: 81,&#125;;var foo = &#123;getX: function() &#123;return this.x;&#125;&#125;console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81console.log(foo.getX.bind(obj)()); //81 看到bind后面对了一对括号。区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。 总结：apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；apply 、 call 、bind 三者都可以利用后续参数传参；bind是返回对应函数，便于稍后调用；apply、call则是立即调用 参考：《call，apply，bind》-Husbin","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript 原型继承","date":"2018-03-27T11:16:19.000Z","path":"2018/03/27/javascript-原型继承与实例化/","text":"1、区分类继承和实例化的差别首先来看两个例子：非常常用的js继承是这个样子的：1B.prototype = new A() 这时候特别容易和实例化给混淆了：1b = new A() 感觉特别的像有木有！这个时候开始好奇new到底干了什么（理解原理非常重要） new一个对象的时候发生了什么1b = new A() 创建空对象 把this指向该空对象，同时还继承了该函数的原型，即临时对象的proto指向构造函数的prototype 执行构造函数中的代码（为这个对象添加属性），也就是赋值。 返回新对象1234567function New (A) &#123; var b = &#123; '__proto__': A.prototype &#125;; /*第一步*/ return function () &#123; A.apply(b, arguments); /*第二步*/ return b; /*第三步*/ &#125;;&#125; 那么怎么区分什么时候是类继承，什么时候是实例化呢？无论是实例化还是继承，本质上都是拥有A的属性，所以要像清楚js是怎么查找一个东西的属性： 当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到给定名称的属性为止。—–出自JavaScript秘密花园 用代码表示如下：123456789function getProperty(obj, prop) &#123; if (obj.hasOwnProperty(prop))&#123; return obj[prop] &#125;else if (obj.__proto__ !== null)&#123; return getProperty(obj.__proto__, prop) &#125;else&#123; return undefined &#125;&#125; 嗯，这下可以解释两者区别了：B.prototype = new A():B.prototype要找自己属性的时候，先看看自己有没有–&gt;看看自己的proto(也就是A.prototype)有没有–&gt;一路往上。b = new A()：b找属性的时候，先看看自己有没有–&gt;看看自己的proto(也就是A.prototype)有没有–&gt;一路往上。 2、实例化众所周知，JavaScript里面所有的数据类型都是对象，我们需要一种机制，将所有的对象联系起来，因此，new命令引入了JavaScript，用来从原型对象生成一个实例对象。在JavaScript语言中，new命令后面跟的不是类，而是构造函数。具体来说两个相关的概念： 类：比如 人类 实例：比如 王小二那么，王小二的父母孕育他到他直到出生的过程，就叫：实例化12345function Human(name)&#123; this.name = name;&#125;var wangxiaoer = new Human('王小二'); //这一步叫作 实例化 3、继承众所周知，JavaScript的继承是实现继承，而没有java中的接口继承。这是因为JavaScript中函数没有签名，而实现继承依靠的是原型链来实现的。 原型继承到底继承了什么？实际上就是继承了构造函数和原型链两个东西。其中构造函数继承使用apply()实现的，这就意味着仅仅是把父类里面的属性复制了一遍，对其进行任何的更改，都不会影响其他的实例，在继承之后对父类进行任何更改也不会影响其子类。而对于原型链的修改，则是表示子类和父类公用原型链上的属性和方法，对于原型链的更改只能从上游源头进行修改，当然子类可以重写父类的方法，不过这样做实际上就是先给子类增添一个重名的方法，而导致JS引擎先调用此方法而不去调用原型链的方法。 原型继承的方法有四种方式可以实现构造函数的继承： 1.调用apply或者call方法12345678910111213function Animal() &#123; this.species = '动物' &#125; Animal.prototype.getName = function() &#123; console.log('我是动物') &#125; function Cat() &#123; Animal.apply(this, arguments) &#125; var cat = new Cat() cat.species // 动物 cat.getName() // undefined 这种方法可以继承父类构造函数的属性，但是无法继承prototype属性，即父类中共享的方法和属性。 2.改写prototype对象12Cat.prototype = new Animal() Cat.prototype.constructor = Cat 这是最常用的方法来模拟单继承，缺点是始终要保留Animal的对象，如果Animal对象比较大时，会消耗部分内存（其实很少），并且没有实现多继承。这种方法构造函数和prototype都会被继承。 3.直接继承prototype12Cat.prototype = Animal.prototype Cat.prototype.constructor = Cat 缺点是当修改了Cat.prototype上的方法时会影响Animal.prototype，也无法访问到构造函数的属性。这种方法可以继承prototype属性，但是无法继承构造函数的属性。 4.利用空对象作中介1234var F = function()&#123;&#125; F.prototype = Animal.prototype Cat.prototype = new F() Cat.prototype.constructor = Cat 缺点是无法继承父类封装的属性，无法访问到构造函数里面的属性,但是可以继承prototype的属性。若要实现封装属性和共享同时继承到子类中，就需要同时结合上面的1和4，请使用jqury的extend方法或者其他深拷贝方法。 参考：js继承与实例化-博客专用马甲Javascript继承机制的设计思想-阮一峰JavaScript 继承的那些事- Ahonn","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS 作用域与闭包","date":"2018-03-27T06:52:43.000Z","path":"2018/03/27/JS-作用域与闭包/","text":"作用域在JavaScript中变量的作用域与其他语言不同，JavaScript的作用域不是由{}来界定，而是函数。所以循环实际上是在全局作用域中。12for(var i = 0; i &lt; 10; i++) &#123;&#125; console.log(i); // 10 全局变量&amp;局部变量JavaScript变量的作用域分为两种，局部和全局。在JavaScript中声明局部变量有两种方式，一种是在全局变量环境下使用var声明（显式声明的全局变量），另一种是在任何地方直接初始化变量，那么它也是全局变量（隐式声明的全局变量）。12345var name = 'Cherryl'; // 全局变量(显式）var age;function f1() &#123; age = '20'; // 还是全局变量（隐式）&#125; 隐式声明的全部变量和显式声明的全部变量的区别：隐式声明的全局变量可以删除，显式声明的全部变量就无法删除。因为通过var声明的式显式全局变量，其实际上是为window对象增加了一个不可配置的属性，而不加var声明的隐式全局变量，其实际上是为window对象增加了一个可以配置的属性。 影响：这样的设计，使得声明和赋值`很容易混淆，造成全局变量的滥用，使许多bug源头之一。 除了在任何地方直接初始化声明全局变量这一特殊之处外，JavaScript全局变量还可以在函数内部直接读取。12345var name = 'Cherryl';function f1() &#123; console.log(name);&#125;f1(); // 'Cherryl' 在函数中使用var定义的变量为局部变量。因为JavaScript的作用域是由函数界定，那么理所因当的函数外部是无法读取函数内部的局部变量。这一点其实其它的变成语言也是这样的。 1234function f1() &#123; var name = 'Cherryl';&#125;alert(name) // name is not defined 作用域链作用域链的原理和原型链很类似。在某个环境中为了读取变量时，会沿着作用域来搜索这个变量，从作用域的前端开始，向上级搜索。如果在当前局部环境中没有找到该变量，则继续沿作用域向上搜索，直到最顶层。搜索到该变量时将停止搜索，如果最后还是没有找到该变量，那么意味着这个变量是未定义的，即它的值为undefined。123456var a = 'a';function f1() &#123; var b = 'b'; console.log(a + b);&#125;f1() // 'ab' 在这个例子中，在全局环境中定义了全局变量a，然后在函数中定义了局部变量b。首先在当前的局部环境中搜索变量a的值，没有找到。那么继续向上一级搜索，在全局环境中找到标识符a的变量的值’a’。接着在全局环境中搜索变量b，得到局部变量b的值’b’。最后输出变量a和b的值拼接后的字符串的值。 闭包函数外部无法读取到函数内部定义的局部变量，所以当我们需要读取局部变量时据需要使用到闭包。 那么闭包是什么呢？我理解是函数返回一个局部作用域来使得函数外部能够读取函数内部的变量。因为JavaScript中作用域的界定是由函数来完成的，所以实际上也就是在函数中再返回一个函数。所以，在本质上，闭包就是将函数内部和外部连接起来的一座桥梁。 闭包的作用主要有两个：一个读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 一般情况下，当函数执行后，函数执行后，函数所在的局部环境将被销毁，也就是说函数在执行后函数中的变量是会被销毁的，在内存中就仅存在全局变量，即全局变量。 但是使用闭包的情况又有所不同，在函数内部定义的匿名函数会包含函数（外部函数）中的变量，在外部函数执行完毕后，原本应该被销毁的局部变量不会被销毁，因为闭包的作用域链仍然存在引用这些局部函数，内存的垃圾回收机制不会回收这部分变量所在的内存空间。直到匿名函数被销毁后，这些局部对象才会被销毁。 123456789101112 function f1()&#123; var n=999; nAdd = function()&#123;n+=1&#125;; function f2() &#123; alert(n) &#125;return f2 &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 内存泄漏由于闭包使得函数中的局部变量不会被垃圾回收机制回收，会依然存在于内存中，所以使用闭包的内存消耗很大，所以大量的使用闭包会造成性能问题，另外，在IE中可能会导致内存泄漏。解决方法是在退出函数前将不使用的局部变量全部删除。 12345678910function f1() &#123; var e = document.getElementById('id'); var id = e.id; e.onclick = function() &#123; alert(id); &#125; e = null; // 删除不使用的局部变量值，只将需要的 id 保存为副本&#125; 改变父函数内部变量的值闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的私有属性(private value)，这时一定要当心，不要随便改变父函数内部变量的值。 参考： 作用域与闭包-Ahonn 学习Javascript闭包-阮一峰","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"hexo的Bluelake主题添加打赏功能","date":"2018-03-26T08:37:16.000Z","path":"2018/03/26/hexo的BlueLake主题添加打赏功能/","text":"打赏是读者对笔者支持的最大动力，作为经常写博客的笔者来说，打赏功能如果在自己的博客中出现，那真的是求之不得呀（虽然基本不会有人来打赏）！然而BlueLake这一主题并没有附加打赏的功能，所以我就自己做一个来玩玩了. 最终效果如下： 1、准备支付宝和微信二维码图片 微信生成二维码教程地址 支付宝生成二维码地址 如果想要追求好看有趣的二维码，可以使用在线二维码美化器 2、编写打赏模块的代码在主题的_partial文件夹下(我的目录为themes/BlueLake/layout/_partial)新增donate.jade文件，内容如下：12345678910111213141516.post-donate #donate_board.donate_bar.center a#btn_donate.btn_donate(href='javascript:;', title='打赏') .donate_txt | &amp;uarr; br != theme.donate.message br #donate_guide.donate_bar.center.hidden.pay img(src=theme.donate.wechatpay, title='微信打赏' alt= '微信打赏') img(src=theme.donate.alipay, title='支付宝打赏' alt= '支付宝打赏') script(type='text/javascript'). document.getElementById('btn_donate').onclick = function()&#123; $('#donate_board').addClass('hidden'); $('#donate_guide').removeClass('hidden'); &#125; 3、增加css文件在主题的css文件夹下（我的目录为themes/BlueLake/source/css）增加donate.styl文件，内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.donate_bar &#123; text-align: center; margin-top: 5%&#125;.pay&#123; display: flex justify-content: space-between&#125;.donate_bar a.btn_donate &#123; display: inline-block; width: 82px; height: 82px; margin-left: auto; margin-right: auto; background: url(http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif)no-repeat; -webkit-transition: background 0s; -moz-transition: background 0s; -o-transition: background 0s; -ms-transition: background 0s; transition: background 0s&#125;.donate_bar a.btn_donate:hover &#123; background-position: 0 -82px&#125;.donate_bar .donate_txt &#123; display: block; color: #5b5b5b; font: 14px/2 \"Microsoft Yahei\"&#125;.donate_bar.hidden&#123; display: none&#125;.post-donate&#123; margin-top: 80px;&#125;#donate_guide&#123; height: 210px; width: 420px; margin: 0 auto;&#125;#donate_guide img&#123; height: 200px; height: 200px;&#125; 4、在base.jade文件中引用css文件在文件themes/maupassant/layout/base.jade的head部分引用donate.styl文件：1link(rel='stylesheet', type='text/css', href=url_for(theme.css) + '/donate.css') 5、在post.jade中加入打赏功能准备工作已经完成，现在可以在themes/BlueLake/layout/post.jade文件中想要显示打赏功能的位置加上如下代码123if theme.donate.enabled == true script(type='text/javascript', src=url_for(theme.js) + '/jquery.js' + '?v=' + theme.version, async) include _partial/donate 这个代码是基于jquery的，所以记得在themes/BlueLake/source/js中引入jquery.js 6、在_config.yml中启用打赏功能在主题_config.yml文件中配置了是否启用打赏功能的配置项，如果配置为true，则启用打赏功能，否则禁止打赏，配置如下：12345donate: enabled: true message: 坚持原创技术分享，您的支持将鼓励我继续创作！ wechatpay: /images/weChatMoney.png alipay: /images/alipayMoney.png 可以发现，在donate.jade文件中也用到了以上配置，message表示打赏标题，wechatpay和alipay分别表示微信/支付宝收款二维码。到这里，一个打赏的功能就实现了！","tags":[]},{"title":"https 和 http 的区别","date":"2018-03-26T02:52:20.000Z","path":"2018/03/26/https-和-http-的区别/","text":"在详细探究HTTP与HTTPS之前，先理清一下HTTP的基本概念： HTTP中文叫做超文本传输协议,是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 在这里，我们需要先提出几个问题：为什么需要使用HTTPS来进行通信？HTTPS在安全上做了哪些事情？ HTTP的特点 HTTP是无连接的：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态的：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP的缺点 容易被监听http通信都是明文，即未加密，内容可能会被窃听。窃听可能发生在互联网通信中的各个环节。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的。 被伪装通信双方的身份没有进行验证，可能出现伪装身份的情况。所有人都可以对服务器发起请求。比如你请求 www.taobao.com ,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。 可以看出，对于客户端来说，无法确定这台Web服务器是否是“真的”服务器，可能通过了伪装。对于服务器来说，也无法确定自己返回的报文是否被真正的客户端接收到。此外，服务器的全盘接收的缺点也会被利用来进行DOS攻击。因此，以客户端为例，客户端在与服务器通信之前需要确定服务器的身份，该身份即是一份证书，该证书有值得信赖的第三方颁发，客户端确认身份后才进行通信。 被篡改接受的报文完整性无法确定，可能中途被改动。hacker中间篡改数据后，接收方并不知道数据已经被更改.我们知道，服务器接收到请求后，会进行响应。但服务器和客户端都无法知道报文中途的传输是否出现了问题。很有可能在传输时被其他攻击者进行了篡改，报文完整性遭到破坏。虽然HTTP提供了确认报文完整性的方法（MD5,SHA-1），但是也无法完全保证报文的完整性。因为MD5本身也可能被攻击者改写。在SSL中，提供了认证和加密处理等功能。通过配合SSL可以达到保证报文完整性的目的。 HTTPS与HTTP协议的差异 HTTP的URL是以“http://”开始，HTTPS的URL是以“https://”开始； HTTP默认端口为80，HTTPS的默认端口为443； 采用HTTPS的Web Server需要到CA申请证书； HTTPS由HTTP+SSL来实现，可进行加密传输、身份认证等，要比HTTP安全 HTTP的信息是明文传输，而HTTPS的信息是加密传输 HTTPS解决的问题：鉴于HTTP的缺点，HTTPS在HTTP的基础上增加了： 通信加密 证书认证 完整性保护 https很好的解决了http的三个缺点（被监听、被篡改、被伪装）https不是一种新的协议，它是http+SSL(TLS)的结合体，SSL是一种独立协议，所以其它协议比如smtp等也可以跟ssl结合。https改变了通信方式，它由以前的http—–&gt;tcp，改为http——&gt;SSL—–&gt;tcp；https采用了共享密钥加密+公开密钥加密的方式 防监听数据是加密的，所以监听得到的数据是密文，hacker看不懂。 防伪装伪装分为客户端伪装和服务器伪装，通信双方携带证书，证书相当于身份证，有证书就认为合法，没有证书就认为非法，证书由第三方颁布，很难伪造 防篡改https对数据做了摘要，篡改数据会被感知到。hacker即使从中改了数据也白搭。 普遍的加密方式共享密钥加密（对称密钥）顾名思义，就是客户端和服务器都拥有一把相同的钥匙，对报文的加密和解密用的都是这把钥匙，而且密钥也需要在通信的过程中发给对方，对方才能通过这把钥匙来解密。因此，一旦在通信过程中，这把密钥被攻击者获取，报文加密便失去了意义。 公开密钥加密共享密钥带来了一个问题就是，如何能够安全地把密钥发送给对方。而公开密钥则较好地解决了这个问题。公开密钥加密使用得是非对称的密钥。一把是公有密钥，一把是私有密钥。公有密钥是对通信双方公开的，任何人都可以获取，而私有的则不公开。发送方使用这把公有密钥对报文进行加密，接收方则使用私有的密钥进行解密。仅仅通过密文和公有密钥是很难破解到密文。使用公开密钥带来安全的同时，也隐藏着一些问题，就是如何保证公开的这把公有密钥的真实性？这个问题伴随也是证书机构。通过证书来保证公有密钥的真实性。 HTTPS采用混合加密机制由于公有密钥的机制相对复杂，导致其处理速度相对较慢。于是HTTPS利用了两者的优势，采用了混合加密的机制。我们知道，共享（对称）密钥未能解决的问题是如何能够安全地把密钥发送给对方。只要解决了这个问题就可以进行安全地通信。于是，HTTPS首先是通过公有密钥来对共享密钥进行加密传输。当共享密钥安全地传输给对方后，双方则使用共享密钥的方式来加密报文，以此来提高传输的效率。 HTTPS的握手机制(建立连接的过程) 步骤1：向服务器发起请求。 步骤2-3：取出公有密钥及证书并发送给客户端。 步骤4：客户端判断公有密钥是否有效，无效则显示警告。有效则生成一个随机数串，并以此生成客户端的共享密钥。 步骤5：用步骤3得到的公有密钥对该随机数串加密，发送到服务器。 步骤6：服务器得到加密报文，用私有密钥解密报文，得到随机数串，并以此生成服务器端的共享密钥。此时客户端和服务端拥有相同的共享密钥，可以用该共享密钥进行安全通信。 步骤7-8：服务器对响应进行加密，客户端对报文进行解密。 选择HTTP还是HTTPS来搭建服务器在比较之前，首先要了解HTTPS存在的问题才能进行权衡。 SSL会使通信的效率降低 通信速率降低HTTPS 除了TCP连接，发送请求，响应之外，还需要进行SSL通信。整体通信信息量增加。 加密过程消耗资源每个报文都需要进行加密和解密的运算处理。比起HTTP会消耗更多的服务器资源。 证书开销如果想要通过HTTPS进行通信，就必须向认证机构购买证书。基于以上三点，如果通信中传输的是非敏感的信息，则会较多地选择HTTP协议。而当通信过程中会涉及个人隐私或其他安全信息时，则会选择用HTTPS。当然，访问量也是考虑的因素之一，如果访问量很大，而每个报文都进行加密解密，也会给服务器带来很大的负担。 参考：深入分析HTTP与HTTPS","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"Hexo搭建博客进阶","date":"2018-03-26T01:51:44.000Z","path":"2018/03/26/Hexo搭建博客进阶/","text":"本文主要讲解如何安装一个好看的hexo主题和讲讲那些我爬过的坑。 一、安装主题我选的是BlueLake这款主题。 可以直接到BlueLake发布页进行配置，相关的配置说明上面都写的非常详细。 安装主题和渲染123$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 启用在Hexo配置文件（hexo/_config.yml）中把主题设置修改为BlueLake。1theme: BlueLake 后面的我就不赘述了，大家参照页面文档进行一步步的配置就好 二、部署时保证README.md文件不被渲染想要写一个README.md文件并更新到github上，却不料每次上传到github后README.md还是会不见。原因是本地的是博客源代码，GitHub上面的是博客生成代码。README.md文件每次更新到github上时都会被解析成.html文件。 其实确保README.md文件不被渲染也挺容易的，只要在博客根目录下的配置文件_config.yml中配置一下”skip_render”选项就行了，将不需要渲染的文件名称加入的其选项下就行了。skip_render: README.md 并将README.md文件放在source下面,就可以保证README.md文件不被渲染啦。 三、webstorm中markdown语法高亮个人最常使用的web编辑器是webstrom，然而webstorm默认是无法高亮md文件的。这个时候我们需要进行简单的配置。 步骤1、打开webstorm，File–&gt;Setting–&gt;输入plugin–&gt;Install JetBrains plugin…–&gt;输入markdown–&gt;点击右边的“Install”,安装完，重启webstorm。 2、新建test.md，然后编辑，如果没有效果的话。File–&gt;Setting–&gt;输入file type–&gt;找到Markdown–&gt;在下面的Registers Patterns添加上*.md。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Mac OS上使用Hexo+github搭建自己的博客","date":"2018-03-25T14:35:17.000Z","path":"2018/03/25/Mac OS上使用Hexo+github搭建自己的博客/","text":"很久以前就想搭建一个个人博客了，之前在公司实习的时候用过Jekyll搭建一个”播客”，最近找实习，偶尔看到东西会做点笔记，所以想着自己搭建一个个人博客，Jekyll其实和Hexo类似，都可以用来搭建播客，目前看到关于Hexo的资源比较多，所以决定使用Hexo来搭建。用下来个人觉得Hexo确实会比jekyll好用很多。作为一个年少无为，买不起服务器，买不起域名的穷low程序媛，就想着使用Hexo搭建一个个人博客，并关联到GitHub上，节省域名费用。欢迎大家在评论区留言，带我装逼带我飞。PS:因本人用的是苹果机，所以本教程以MACOS为参考，但mac与windows搭建的方法步骤其实相差无几。主要参考文章使用Hexo+Github一步步搭建属于自己的博客（基础） 相关步骤1、安装node.js和配置好node.js环境，这里不详细说，推荐使用homebrew安装。请参考node.js在mac上环境安装与测试.成功界面如下： 2、安装git和配置好git环境，这里我也是用homebrew直接安装的。成功界面如下： 3、安装Hexo，在自己认为合适的地方创一个新文件夹，用来保存博客的相关项目代码。输入npm install hexo –g,开始安装Hexo。（我这样直接安装的时候发生了个错误，提示没有权限，所以我在前面又加了一个sudo）。输入hexo-v，检查hexo是否安装成功。输入hexo init，初始化该文件看到Start blogging with Hexo！初始化完成！输入npm install ，安装所需要的组件。输入hexo g ，首次体验hexo。输入hexo s ,开启服务器，访问该网址，正式体验hexo（加入页面一直无法跳转，那么端口可能被占用了，此时我们ctrl+c停止服务器，接着输入”hexo server –p 端口号”来改变端口号）出现下图就成功了！ 4、Github账户注册和新建项目项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README。(这里我第一次的时候账户名写错了，导致后来本地的样式和github显示的不一致，后来我将下图中的myBlog改为我的账户名liuqian0413就显示正常了。大家记住一定不要写错了！)在建立好的项目右上方有个setting按钮，点击，向下拉到Github Pages，你会看到该项目已经被部署到网络上，能够用外网来访问它。（如果没有出现地址，将souce那一栏的第一个参数选为master branch，然后点击save后就会刷新出来） 5、将Hexo与Github Page联系起来输入cd ~/.ssh，检查是否有.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 如果没有找到该文件，输入ssh-keygen -t rsa -C &quot;784575932@.com &quot;（这里的邮箱填写你注册GitHub时候自己的邮箱）,连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub 接着输入eval &quot;$(ssh-agent -s)&quot;，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent. 接着登录Github，点击头像下的settings，添加ssh 复制id_rsa.pub文件里面的内容，我们可以使用vim id_rsa.pub查看 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决首先，清除所有的key-pair:ssh-add -Drm -r ~/.ssh删除你在GitHub中的public-key重新生成ssh密钥对ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;接下来正常操作：在GitHub上添加公钥public-key:1.首先在你的终端运行xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2.在github上添加公钥时，直接复制即可3.保存测试：在终端ssh -T git@github.com 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh(右下角) 6、新建博客并发布新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件: 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","date":"2018-03-25T13:13:48.372Z","path":"2018/03/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]