<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cherryl</title>
  
  <subtitle>Stay foolish, Stay hungry</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-01T11:22:46.090Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘倩Chenny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript 原型继承</title>
    <link href="http://yoursite.com/2018/03/27/javascript-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2018/03/27/javascript-原型继承与实例化/</id>
    <published>2018-03-27T11:16:19.000Z</published>
    <updated>2018-04-01T11:22:46.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、区分类继承和实例化的差别"><a href="#1、区分类继承和实例化的差别" class="headerlink" title="1、区分类继承和实例化的差别"></a>1、区分类继承和实例化的差别</h1><p>首先来看两个例子：<br>非常常用的js继承是这个样子的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = <span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure></p><p>这时候特别容易和实例化给混淆了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure></p><p>感觉特别的像有木有！这个时候开始好奇new到底干了什么（理解原理非常重要）</p><h2 id="new一个对象的时候发生了什么"><a href="#new一个对象的时候发生了什么" class="headerlink" title="new一个对象的时候发生了什么"></a>new一个对象的时候发生了什么</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure><ul><li>创建空对象</li><li>把this指向该空对象，同时还继承了该函数的原型，即临时对象的<em>proto</em>指向构造函数的prototype</li><li>执行构造函数中的代码（为这个对象添加属性），也就是赋值。</li><li>返回新对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span> (<span class="params">A</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> b = &#123; <span class="string">'__proto__'</span>: A.prototype &#125;; <span class="comment">/*第一步*/</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        A.apply(b, <span class="built_in">arguments</span>); <span class="comment">/*第二步*/</span> </span><br><span class="line">        <span class="keyword">return</span> b; <span class="comment">/*第三步*/</span></span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那么怎么区分什么时候是类继承，什么时候是实例化呢？<br>无论是实例化还是继承，本质上都是拥有A的属性，所以要像清楚js是怎么查找一个东西的属性：</p><blockquote><p>当查找一个对象的属性时，JavaScript会<strong>向上</strong>遍历原型链，直到找到给定名称的属性为止。—–出自JavaScript秘密花园</p></blockquote><p>用代码表示如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>(<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(prop))&#123;</span><br><span class="line">        <span class="keyword">return</span> obj[prop]</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (obj.__proto__ !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> getProperty(obj.__proto__, prop)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>嗯，这下可以解释两者区别了：<br><code>B.prototype = new A()</code>:<strong>B.prototype</strong>要找自己属性的时候，先看看自己有没有–&gt;看看自己的proto(也就是A.prototype)有没有–&gt;一路往上。<br><code>b = new A()</code>：<strong>b</strong>找属性的时候，先看看自己有没有–&gt;看看自己的proto(也就是A.prototype)有没有–&gt;一路往上。</p><h1 id="2、实例化"><a href="#2、实例化" class="headerlink" title="2、实例化"></a>2、实例化</h1><p>众所周知，JavaScript里面所有的数据类型都是对象，我们需要一种机制，将所有的对象联系起来，因此，new命令引入了<br>JavaScript，用来从原型对象生成一个实例对象。在JavaScript语言中，new命令后面跟的不是类，而是构造函数。<br>具体来说<br>两个相关的概念：</p><ul><li>类：比如 人类</li><li>实例：比如 王小二<br>那么，王小二的父母孕育他到他直到出生的过程，就叫：实例化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wangxiaoer = <span class="keyword">new</span> Human(<span class="string">'王小二'</span>); <span class="comment">//这一步叫作 实例化</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3、继承"><a href="#3、继承" class="headerlink" title="3、继承"></a>3、继承</h1><p>众所周知，JavaScript的继承是实现继承，而没有java中的接口继承。这是因为JavaScript中函数没有签名，而实现继承依靠的是原型链来实现的。</p><h2 id="原型继承到底继承了什么？"><a href="#原型继承到底继承了什么？" class="headerlink" title="原型继承到底继承了什么？"></a>原型继承到底继承了什么？</h2><p>实际上就是继承了<strong>构造函数</strong>和<strong>原型链</strong>两个东西。其中构造函数继承使用<code>apply()</code>实现的，这就意味着仅仅是把父类里面的属性复制了<br>一遍，对其进行任何的更改，都不会影响其他的实例，在继承之后对父类进行任何更改也不会影响其子类。而对于原型链的修改，<br>则是表示子类和父类公用原型链上的属性和方法，对于原型链的更改只能从上游源头进行修改，当然子类可以重写父类的方法，不过这样做实际上<br>就是先给子类增添一个重名的方法，而导致JS引擎先调用此方法而不去调用原型链的方法。</p><h2 id="原型继承的方法"><a href="#原型继承的方法" class="headerlink" title="原型继承的方法"></a>原型继承的方法</h2><p>有四种方式可以实现构造函数的继承：</p><ul><li><strong>1.调用apply或者call方法</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">'动物'</span>  </span><br><span class="line">&#125;  </span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是动物'</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat()  </span><br><span class="line">cat.species    <span class="comment">// 动物  </span></span><br><span class="line">cat.getName()  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><p>这种方法<strong>可以继承父类构造函数的属性</strong>，但是<strong>无法继承prototype属性</strong>，即父类中共享的方法和属性。</p><ul><li><strong>2.改写prototype对象</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal()  </span><br><span class="line">Cat.prototype.constructor = Cat</span><br></pre></td></tr></table></figure></li></ul><p>这是最常用的方法来模拟单继承，缺点是始终要保留Animal的对象，如果Animal对象比较大时，会<strong>消耗部分内存</strong>（其实很少），并且<strong>没有实现多继承</strong>。这种方法构造函数和prototype都会被继承。</p><ul><li><strong>3.直接继承prototype</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = Animal.prototype  </span><br><span class="line">Cat.prototype.constructor = Cat</span><br></pre></td></tr></table></figure></li></ul><p>缺点是当修改了Cat.prototype上的方法时会影响Animal.prototype，也无法访问到构造函数的属性。这种方法<strong>可以继承prototype属性</strong>，但是<strong>无法继承构造函数的属性</strong>。</p><ul><li><strong>4.利用空对象作中介</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  </span><br><span class="line">F.prototype = Animal.prototype  </span><br><span class="line">Cat.prototype = <span class="keyword">new</span> F()  </span><br><span class="line">Cat.prototype.constructor = Cat</span><br></pre></td></tr></table></figure></li></ul><p>缺点是<strong>无法继承父类封装的属性</strong>，<strong>无法访问到构造函数里面的属性</strong>,但是<strong>可以继承prototype的属性</strong>。<br><strong>若要实现封装属性和共享同时继承到子类中，就需要同时结合上面的1和4，请使用jqury的extend方法或者其他深拷贝方法。</strong></p><p>参考：<br><a href="https://www.jianshu.com/p/3255d9eb8ece" target="_blank" rel="noopener">js继承与实例化-博客专用马甲</a><br><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想-阮一峰</a><br><a href="http://www.ahonn.me/2017/01/24/something-about-javaScript-inherit/" target="_blank" rel="noopener">JavaScript 继承的那些事- Ahonn</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、区分类继承和实例化的差别&quot;&gt;&lt;a href=&quot;#1、区分类继承和实例化的差别&quot; class=&quot;headerlink&quot; title=&quot;1、区分类继承和实例化的差别&quot;&gt;&lt;/a&gt;1、区分类继承和实例化的差别&lt;/h1&gt;&lt;p&gt;首先来看两个例子：&lt;br&gt;非常常用的js继承
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS 作用域与闭包</title>
    <link href="http://yoursite.com/2018/03/27/JS-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/03/27/JS-作用域与闭包/</id>
    <published>2018-03-27T06:52:43.000Z</published>
    <updated>2018-03-28T02:38:07.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>在JavaScript中变量的作用域与其他语言不同，JavaScript的作用域不是由<code>{}</code>来界定，而是<code>函数</code>。所以<strong>循环实际上是在全局作用域中</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><h2 id="全局变量-amp-局部变量"><a href="#全局变量-amp-局部变量" class="headerlink" title="全局变量&amp;局部变量"></a>全局变量&amp;局部变量</h2><p>JavaScript变量的作用域分为两种，<strong>局部</strong>和<strong>全局</strong>。<br>在JavaScript中声明局部变量有两种方式，一种是在全局变量环境下使用<code>var</code>声明（显式声明的全局变量），另一种是在任何地方直接初始化变量，那么它也是全局变量（隐式声明的全局变量）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Cherryl'</span>;   <span class="comment">// 全局变量(显式）</span></span><br><span class="line"><span class="keyword">var</span> age;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  age = <span class="string">'20'</span>;   <span class="comment">// 还是全局变量（隐式）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="隐式声明的全部变量和显式声明的全部变量的区别："><a href="#隐式声明的全部变量和显式声明的全部变量的区别：" class="headerlink" title="隐式声明的全部变量和显式声明的全部变量的区别："></a>隐式声明的全部变量和显式声明的全部变量的区别：</h3><p>隐式声明的全局变量可以删除，显式声明的全部变量就无法删除。<br>因为通过<code>var</code>声明的式显式全局变量，其实际上是为<code>window</code>对象增加了一个<strong>不可配置</strong>的属性，而不加<code>var</code>声明的隐式全局变量，其实际上是为<code>window</code>对象增加了一个<strong>可以配置</strong>的属性。</p><p><strong>影响</strong>：这样的设计，使得<code>声明</code>和<code>赋值`</code>很容易混淆，造成全局变量的滥用，使许多bug源头之一。</p><p>除了在任何地方直接初始化声明全局变量这一特殊之处外，JavaScript全局变量还可以在<strong>函数内部直接读取</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Cherryl'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">f1(); <span class="comment">// 'Cherryl'</span></span><br></pre></td></tr></table></figure></p><p>在函数中使用var定义的变量为局部变量。因为JavaScript的作用域是由函数界定，那么理所因当的函数外部是无法读取函数内部的局部变量。这一点其实其它的变成语言也是这样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Cherryl'</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(name) <span class="comment">//  name is not defined</span></span><br></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链的原理和原型链很类似。在某个环境中为了读取变量时，会沿着作用域来搜索这个变量，从作用域的前端开始，向上级搜索。如果在当前局部环境中没有找到该变量，则继续沿作用域向上搜索，直到最顶层。搜索到该变量时将停止搜索，如果最后还是没有找到该变量，那么意味着这个变量是未定义的，即它的值为<code>undefined</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'b'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// 'ab'</span></span><br></pre></td></tr></table></figure></p><p>在这个例子中，在全局环境中定义了全局变量a，然后在函数中定义了局部变量b。首先在当前的局部环境中搜索变量a的值，没有找到。那么继续向上一级搜索，在全局环境中找到标识符a的变量的值’a’。接着在全局环境中搜索变量b，得到局部变量b的值’b’。最后输出变量a和b的值拼接后的字符串的值。</p><hr><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>函数外部无法读取到函数内部定义的局部变量，所以当我们需要读取局部变量时据需要使用到闭包。</p><p>那么闭包是什么呢？我理解是函数返回一个局部作用域来使得函数外部能够读取函数内部的变量。因为JavaScript中作用域的界定是由函数来完成的，所以实际上也就是在函数中再返回一个函数。所以，在本质上，闭包就是将函数内部和外部连接起来的一座桥梁。</p><p><strong>闭包的作用主要有两个：一个读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</strong></p><p>一般情况下，当函数执行后，函数执行后，函数所在的局部环境将被销毁，也就是说函数在执行后函数中的变量是会被销毁的，在内存中就仅存在全局变量，即全局变量。</p><p>但是使用闭包的情况又有所不同，在函数内部定义的匿名函数会包含函数（外部函数）中的变量，在外部函数执行完毕后，原本应该被销毁的局部变量不会被销毁，因为闭包的作用域链仍然存在引用这些局部函数，内存的垃圾回收机制不会回收这部分变量所在的内存空间。直到匿名函数被销毁后，这些局部对象才会被销毁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;  </span><br><span class="line">　　　　nAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f2</span><br><span class="line">　　&#125;  </span><br><span class="line">　　<span class="keyword">var</span> result=f1();  </span><br><span class="line">　　result(); <span class="comment">// 999  </span></span><br><span class="line">　　nAdd();  </span><br><span class="line">　　result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>由于闭包使得函数中的局部变量不会被垃圾回收机制回收，会依然存在于内存中，所以使用闭包的内存消耗很大，所以大量的使用闭包会造成性能问题，另外，在IE中可能会导致内存泄漏。解决方法是在退出函数前将不使用的局部变量全部删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="built_in">document</span>.getElementById(<span class="string">'id'</span>);</span><br><span class="line">  <span class="keyword">var</span> id = e.id;</span><br><span class="line"></span><br><span class="line">  e.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e = <span class="literal">null</span>; <span class="comment">// 删除不使用的局部变量值，只将需要的 id 保存为副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改变父函数内部变量的值"><a href="#改变父函数内部变量的值" class="headerlink" title="改变父函数内部变量的值"></a>改变父函数内部变量的值</h2><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的私有属性(private value)，这时一定要当心，不要随便改变父函数内部变量的值。</p><hr><p>参考：</p><ul><li><a href="http://www.ahonn.me/2016/04/04/javascript-closures/" target="_blank" rel="noopener">作用域与闭包-Ahonn</a></li><li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">学习Javascript闭包-阮一峰</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;p&gt;在JavaScript中变量的作用域与其他语言不同，JavaScript的作用域不是由&lt;code&gt;{}&lt;/code&gt;来界定，而是&lt;c
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>hexo的Bluelake主题添加打赏功能</title>
    <link href="http://yoursite.com/2018/03/26/hexo%E7%9A%84BlueLake%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2018/03/26/hexo的BlueLake主题添加打赏功能/</id>
    <published>2018-03-26T08:37:16.000Z</published>
    <updated>2018-03-27T01:44:11.142Z</updated>
    
    <content type="html"><![CDATA[<p>打赏是读者对笔者支持的最大动力，作为经常写博客的笔者来说，打赏功能如果在自己的博客中出现，那真的是求之不得呀（虽然基本不会有人来打赏）！<br>然而BlueLake这一主题并没有附加打赏的功能，所以我就自己做一个来玩玩了.</p><p>最终效果如下：<br><img src="/images/hexoMoney/hexoMoney01.png" alt="Alt text"></p><h2 id="1、准备支付宝和微信二维码图片"><a href="#1、准备支付宝和微信二维码图片" class="headerlink" title="1、准备支付宝和微信二维码图片"></a>1、准备支付宝和微信二维码图片</h2><ul><li>微信生成二维码教程<a href="https://jingyan.baidu.com/article/b907e627b641b646e6891c6b.html" target="_blank" rel="noopener">地址</a></li><li>支付宝生成二维码<a href="https://qr.alipay.com/paipai/open.htm" target="_blank" rel="noopener">地址</a></li><li>如果想要追求好看有趣的二维码，可以使用<a href="http://www.liantu.com/meihua/" target="_blank" rel="noopener">在线二维码美化器</a></li></ul><h2 id="2、编写打赏模块的代码"><a href="#2、编写打赏模块的代码" class="headerlink" title="2、编写打赏模块的代码"></a>2、编写打赏模块的代码</h2><p>在主题的_partial文件夹下(我的目录为<code>themes/BlueLake/layout/_partial</code>)新增<code>donate.jade</code>文件，内容如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.post-donate</span><br><span class="line">    #donate_board.donate_bar.center</span><br><span class="line">        a#btn_donate.btn_donate(href='javascript:;', title='打赏')</span><br><span class="line">        .donate_txt</span><br><span class="line">            |  &amp;uarr;</span><br><span class="line">            br</span><br><span class="line">            != theme.donate.message</span><br><span class="line">            br</span><br><span class="line">    #donate_guide.donate_bar.center.hidden.pay</span><br><span class="line">        img(src=theme.donate.wechatpay, title=<span class="string">'微信打赏'</span> alt= <span class="string">'微信打赏'</span>)</span><br><span class="line">        img(src=theme.donate.alipay, title=<span class="string">'支付宝打赏'</span> alt= <span class="string">'支付宝打赏'</span>)</span><br><span class="line">    script(type=<span class="string">'text/javascript'</span>).</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'btn_donate'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="string">'#donate_board'</span>).addClass(<span class="string">'hidden'</span>);</span><br><span class="line">            $(<span class="string">'#donate_guide'</span>).removeClass(<span class="string">'hidden'</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="3、增加css文件"><a href="#3、增加css文件" class="headerlink" title="3、增加css文件"></a>3、增加css文件</h2><p>在主题的css文件夹下（我的目录为<code>themes/BlueLake/source/css</code>）增加<code>donate.styl</code>文件，内容如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.donate_bar</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">5%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pay</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">  justify-content: space-between</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.donate_bar</span> <span class="selector-tag">a</span><span class="selector-class">.btn_donate</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">82px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">82px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif)<span class="built_in">no-repeat</span>;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: background <span class="number">0s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: background <span class="number">0s</span>;</span><br><span class="line">  <span class="attribute">-o-transition</span>: background <span class="number">0s</span>;</span><br><span class="line">  <span class="attribute">-ms-transition</span>: background <span class="number">0s</span>;</span><br><span class="line">  <span class="attribute">transition</span>: background <span class="number">0s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.donate_bar</span> <span class="selector-tag">a</span><span class="selector-class">.btn_donate</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">82px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.donate_bar</span> <span class="selector-class">.donate_txt</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#5b5b5b</span>;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">14px</span>/<span class="number">2</span> <span class="string">"Microsoft Yahei"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.donate_bar</span><span class="selector-class">.hidden</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-donate</span>&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#donate_guide</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">210px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">420px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#donate_guide</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4、在base-jade文件中引用css文件"><a href="#4、在base-jade文件中引用css文件" class="headerlink" title="4、在base.jade文件中引用css文件"></a>4、在base.jade文件中引用css文件</h2><p>在文件<code>themes/maupassant/layout/base.jade</code>的head部分引用<code>donate.styl</code>文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link(rel=<span class="string">'stylesheet'</span>, type=<span class="string">'text/css'</span>, href=url_for(theme.css) + <span class="string">'/donate.css'</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/images/hexoMoney/hexoMoney02.png" alt="Alt text"></p><h2 id="5、在post-jade中加入打赏功能"><a href="#5、在post-jade中加入打赏功能" class="headerlink" title="5、在post.jade中加入打赏功能"></a>5、在post.jade中加入打赏功能</h2><p>准备工作已经完成，现在可以在<code>themes/BlueLake/layout/post.jade</code>文件中想要显示打赏功能的位置加上如下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.donate.enabled == <span class="literal">true</span></span><br><span class="line">  script(type=<span class="string">'text/javascript'</span>, src=url_for(theme.js) + <span class="string">'/jquery.js'</span> + <span class="string">'?v='</span> + theme.version, <span class="keyword">async</span>)</span><br><span class="line">  include _partial/donate</span><br></pre></td></tr></table></figure></p><p><img src="/images/hexoMoney/hexoMoney03.png" alt="Alt text"><br><strong>这个代码是基于jquery的，所以记得在<code>themes/BlueLake/source/js</code>中引入<a href="http://www.jq22.com/jquery-info122" target="_blank" rel="noopener">jquery.js</a></strong><br><img src="/images/hexoMoney/hexoMoney04.jpg" alt="Alt text"></p><h2 id="6、在-config-yml中启用打赏功能"><a href="#6、在-config-yml中启用打赏功能" class="headerlink" title="6、在_config.yml中启用打赏功能"></a>6、在_config.yml中启用打赏功能</h2><p>在主题<code>_config.yml</code>文件中配置了是否启用打赏功能的配置项，如果配置为<code>true</code>，则启用打赏功能，否则禁止打赏，配置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">donate:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  message: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">  wechatpay: <span class="regexp">/images/</span>weChatMoney.png</span><br><span class="line">  alipay: <span class="regexp">/images/</span>alipayMoney.png</span><br></pre></td></tr></table></figure></p><p>可以发现，在donate.jade文件中也用到了以上配置，message表示打赏标题，wechatpay和alipay分别表示微信/支付宝收款二维码。<br>到这里，一个打赏的功能就实现了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打赏是读者对笔者支持的最大动力，作为经常写博客的笔者来说，打赏功能如果在自己的博客中出现，那真的是求之不得呀（虽然基本不会有人来打赏）！&lt;br&gt;然而BlueLake这一主题并没有附加打赏的功能，所以我就自己做一个来玩玩了.&lt;/p&gt;
&lt;p&gt;最终效果如下：&lt;br&gt;&lt;img sr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>https 和 http 的区别</title>
    <link href="http://yoursite.com/2018/03/26/https-%E5%92%8C-http-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/26/https-和-http-的区别/</id>
    <published>2018-03-26T02:52:20.000Z</published>
    <updated>2018-03-27T03:25:17.658Z</updated>
    
    <content type="html"><![CDATA[<p>在详细探究HTTP与HTTPS之前，先理清一下HTTP的<code>基本概念</code>：</p><blockquote><p><strong>HTTP</strong>中文叫做超文本传输协议,是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。</p></blockquote><blockquote><p><strong>HTTPS</strong>（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</p></blockquote><p>在这里，我们需要先提出几个问题：<br><strong>为什么需要使用HTTPS来进行通信？HTTPS在安全上做了哪些事情？</strong></p><hr><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><ul><li><strong>HTTP是无连接的：</strong>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><strong>HTTP是媒体独立的：</strong>只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li><li><strong>HTTP是无状态的：</strong>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><hr><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ul><li><p><strong>容易被监听</strong><br><code>http通信都是明文，即未加密，内容可能会被窃听。</code>窃听可能发生在互联网通信中的各个环节。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的。<br><img src="/images/http/http01.png" alt="Alt text"></p></li><li><p><strong>被伪装</strong><br><code>通信双方的身份没有进行验证，可能出现伪装身份的情况。</code>所有人都可以对服务器发起请求。比如你请求 <a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> ,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。</p></li></ul><p><img src="/images/http/http02.png" alt="Alt text"></p><p>可以看出，对于客户端来说，无法确定这台Web服务器是否是“真的”服务器，可能通过了<code>伪装</code>。对于服务器来说，也无法确定自己返回的报文是否被真正的客户端接收到。<br>此外，服务器的全盘接收的缺点也会被利用来进行DOS攻击。<br>因此，以客户端为例，客户端在与服务器通信之前需要确定服务器的身份，该身份即是一份证书，该证书有值得信赖的第三方颁发，客户端确认身份后才进行通信。<br><img src="/images/http/http03.png" alt="Alt text"></p><ul><li><strong>被篡改</strong><br><code>接受的报文完整性无法确定，可能中途被改动。</code>hacker中间篡改数据后，接收方并不知道数据已经被更改.我们知道，服务器接收到请求后，会进行响应。但服务器和客户端都无法知道报文中途的传输是否出现了问题。很有可能在传输时被其他攻击者进行了篡改，报文完整性遭到破坏。<br><img src="/images/http/http04.png" alt="Alt text"><br>虽然HTTP提供了确认报文完整性的方法（MD5,SHA-1），但是也无法完全保证报文的完整性。因为MD5本身也可能被攻击者改写。在SSL中，提供了认证和加密处理等功能。通过配合SSL可以达到保证报文完整性的目的。</li></ul><hr><h2 id="HTTPS与HTTP协议的差异"><a href="#HTTPS与HTTP协议的差异" class="headerlink" title="HTTPS与HTTP协议的差异"></a>HTTPS与HTTP协议的差异</h2><ul><li>HTTP的URL是以“http://”开始，HTTPS的URL是以“https://”开始；</li><li>HTTP默认端口为80，HTTPS的默认端口为443；</li><li>采用HTTPS的Web Server需要到CA申请证书；</li><li>HTTPS由HTTP+SSL来实现，可进行加密传输、身份认证等，要比HTTP安全</li><li>HTTP的信息是明文传输，而HTTPS的信息是加密传输</li></ul><hr><h2 id="HTTPS解决的问题："><a href="#HTTPS解决的问题：" class="headerlink" title="HTTPS解决的问题："></a>HTTPS解决的问题：</h2><h3 id="鉴于HTTP的缺点，HTTPS在HTTP的基础上增加了："><a href="#鉴于HTTP的缺点，HTTPS在HTTP的基础上增加了：" class="headerlink" title="鉴于HTTP的缺点，HTTPS在HTTP的基础上增加了："></a>鉴于HTTP的缺点，HTTPS在HTTP的基础上增加了：</h3><ul><li><strong>通信加密</strong></li><li><strong>证书认证</strong></li><li><strong>完整性保护</strong></li></ul><h3 id="https很好的解决了http的三个缺点（被监听、被篡改、被伪装）"><a href="#https很好的解决了http的三个缺点（被监听、被篡改、被伪装）" class="headerlink" title="https很好的解决了http的三个缺点（被监听、被篡改、被伪装）"></a>https很好的解决了http的三个缺点（被监听、被篡改、被伪装）</h3><p>https不是一种新的协议，它是http+SSL(TLS)的结合体，SSL是一种独立协议，所以其它协议比如smtp等也可以跟ssl结合。https改变了通信方式，它由以前的http—–&gt;tcp，改为http——&gt;SSL—–&gt;tcp；https采用了共享密钥加密+公开密钥加密的方式</p><ul><li><strong>防监听</strong><br>数据是加密的，所以监听得到的数据是密文，hacker看不懂。</li><li><strong>防伪装</strong><br>伪装分为客户端伪装和服务器伪装，通信双方携带证书，证书相当于身份证，有证书就认为合法，没有证书就认为非法，证书由第三方颁布，很难伪造</li><li><strong>防篡改</strong><br>https对数据做了摘要，篡改数据会被感知到。hacker即使从中改了数据也白搭。</li></ul><hr><h2 id="普遍的加密方式"><a href="#普遍的加密方式" class="headerlink" title="普遍的加密方式"></a>普遍的加密方式</h2><h3 id="共享密钥加密（对称密钥）"><a href="#共享密钥加密（对称密钥）" class="headerlink" title="共享密钥加密（对称密钥）"></a>共享密钥加密（对称密钥）</h3><p>顾名思义，就是客户端和服务器都拥有一把<strong>相同的钥匙</strong>，对报文的加密和解密用的都是这把钥匙，而且密钥也需要在通信的过程中发给对方，对方才能通过这把钥匙来解密。因此，一旦在通信过程中，这把密钥被攻击者获取，报文加密便失去了意义。<br><img src="/images/http/http05.png" alt="Alt text"></p><h3 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h3><p>共享密钥带来了一个问题就是，<strong>如何能够安全地把密钥发送给对方</strong>。而公开密钥则较好地解决了这个问题。<br>公开密钥加密使用得是非对称的密钥。一把是公有密钥，一把是私有密钥。公有密钥是对通信双方公开的，任何人都可以获取，而私有的则不公开。发送方使用这把公有密钥对报文进行加密，接收方则使用私有的密钥进行解密。仅仅通过密文和公有密钥是很难破解到密文。<br>使用公开密钥带来安全的同时，也隐藏着一些问题，就是如何保证公开的这把公有密钥的真实性？这个问题伴随也是证书机构。通过证书来保证公有密钥的真实性。<br><img src="/images/http/http06.png" alt="Alt text"></p><h3 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h3><p>由于公有密钥的机制相对复杂，导致其处理速度相对较慢。于是HTTPS利用了两者的优势，采用了混合加密的机制。我们知道，<br>共享（对称）密钥未能解决的问题是<strong>如何能够安全地把密钥发送给对方</strong>。只要解决了这个问题就可以进行安全地通信。于是，<br>HTTPS首先是通过<strong>公有密钥</strong>来对<strong>共享密钥</strong>进行加密传输。当<strong>共享密钥安全地传输给对方</strong>后，双方则使用共享密钥的方式来加密报文，<br>以此来提高传输的效率。</p><hr><h2 id="HTTPS的握手机制-建立连接的过程"><a href="#HTTPS的握手机制-建立连接的过程" class="headerlink" title="HTTPS的握手机制(建立连接的过程)"></a>HTTPS的握手机制(建立连接的过程)</h2><p><img src="/images/http/http07.png" alt="Alt text"></p><ul><li><strong>步骤1：</strong>向服务器发起请求。</li><li><strong>步骤2-3：</strong>取出公有密钥及证书并发送给客户端。</li><li><strong>步骤4：</strong>客户端判断公有密钥是否有效，无效则显示警告。有效则生成一个随机数串，并以此生成客户端的共享密钥。</li><li><strong>步骤5：</strong>用步骤3得到的公有密钥对该随机数串加密，发送到服务器。</li><li><strong>步骤6：</strong>服务器得到加密报文，用私有密钥解密报文，得到随机数串，并以此生成服务器端的共享密钥。此时客户端和服务端拥有相同的共享密钥，可以用该共享密钥进行安全通信。</li><li><strong>步骤7-8：</strong>服务器对响应进行加密，客户端对报文进行解密。</li></ul><hr><h2 id="选择HTTP还是HTTPS来搭建服务器"><a href="#选择HTTP还是HTTPS来搭建服务器" class="headerlink" title="选择HTTP还是HTTPS来搭建服务器"></a>选择HTTP还是HTTPS来搭建服务器</h2><p>在比较之前，首先要了解<strong>HTTPS存在的问题</strong>才能进行权衡。</p><h3 id="SSL会使通信的效率降低"><a href="#SSL会使通信的效率降低" class="headerlink" title="SSL会使通信的效率降低"></a>SSL会使通信的效率降低</h3><ul><li><strong>通信速率降低</strong><br>HTTPS 除了TCP连接，发送请求，响应之外，还需要进行SSL通信。整体通信信息量增加。</li><li><strong>加密过程消耗资源</strong><br>每个报文都需要进行加密和解密的运算处理。比起HTTP会消耗更多的服务器资源。</li><li><strong>证书开销</strong><br>如果想要通过HTTPS进行通信，就必须向认证机构购买证书。<br>基于以上三点，如果通信中传输的是<strong>非敏感的信息</strong>，则会较多地选择HTTP协议。而当通信过程中会涉及<strong>个人隐私<br>或其他安全信息</strong>时，则会选择用HTTPS。当然，访问量也是考虑的因素之一，如果访问量很大，而每个报文都进行加密解密，也会给服务器带来很大的负担。</li></ul><hr><p>参考：<a href="https://www.jianshu.com/p/d286d097e56b" target="_blank" rel="noopener">深入分析HTTP与HTTPS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在详细探究HTTP与HTTPS之前，先理清一下HTTP的&lt;code&gt;基本概念&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt;中文叫做超文本传输协议,是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Intern
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客进阶</title>
    <link href="http://yoursite.com/2018/03/26/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/03/26/Hexo搭建博客进阶/</id>
    <published>2018-03-26T01:51:44.000Z</published>
    <updated>2018-03-26T02:32:52.300Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解如何安装一个好看的hexo主题和讲讲那些我爬过的坑。</p><h2 id="一、安装主题"><a href="#一、安装主题" class="headerlink" title="一、安装主题"></a>一、安装主题</h2><p>我选的是<a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/README.md" target="_blank" rel="noopener">BlueLake</a>这款主题。</p><p>可以直接到<a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/README.md" target="_blank" rel="noopener">BlueLake发布页</a>进行配置，相关的配置说明上面都写的非常详细。<br><img src="/images/hexoAdvance/hexoAdvance01.png" alt="Alt text"></p><h3 id="安装主题和渲染"><a href="#安装主题和渲染" class="headerlink" title="安装主题和渲染"></a>安装主题和渲染</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake</span><br><span class="line">$ npm install hexo-renderer-jade@0.3.0 --save</span><br><span class="line">$ npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><p>在Hexo配置文件（<code>hexo/_config.yml</code>）中把主题设置修改为<code>BlueLake</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: BlueLake</span><br></pre></td></tr></table></figure></p><p>后面的我就不赘述了，大家参照页面文档进行一步步的配置就好</p><h2 id="二、部署时保证README-md文件不被渲染"><a href="#二、部署时保证README-md文件不被渲染" class="headerlink" title="二、部署时保证README.md文件不被渲染"></a>二、部署时保证README.md文件不被渲染</h2><p>想要写一个README.md文件并更新到github上，却不料每次上传到github后README.md还是会<br>不见。原因是本地的是博客源代码，GitHub上面的是博客生成代码。README.md文件每次更新到github上<br>时都会被解析成.html文件。</p><p>其实确保README.md文件不被渲染也挺容易的，只要在博客根目录下的配置文件_config.yml中配置一下”skip_render”选项就行了，将不需要渲染的文件名称加入的其选项下就行了。<br><code>skip_render: README.md</code></p><p>并将README.md文件放在source下面,就可以保证README.md文件不被渲染啦。</p><h2 id="三、webstorm中markdown语法高亮"><a href="#三、webstorm中markdown语法高亮" class="headerlink" title="三、webstorm中markdown语法高亮"></a>三、webstorm中markdown语法高亮</h2><p>个人最常使用的web编辑器是webstrom，然而webstorm默认是无法高亮md文件的。这个时候我们需要进行<br>简单的配置。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、打开webstorm，File–&gt;Setting–&gt;输入plugin–&gt;Install JetBrains plugin…–&gt;输入markdown–&gt;点击右边的“Install”,安装完，重启webstorm。<br><img src="/images/hexoAdvance/hexoAdvance02.jpg" alt="Alt text"></p><p>2、新建test.md，然后编辑，如果没有效果的话。File–&gt;Setting–&gt;输入file type–&gt;找到Markdown–&gt;在下面的Registers Patterns添加上*.md。<br><img src="/images/hexoAdvance/hexoAdvance03.jpg" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讲解如何安装一个好看的hexo主题和讲讲那些我爬过的坑。&lt;/p&gt;
&lt;h2 id=&quot;一、安装主题&quot;&gt;&lt;a href=&quot;#一、安装主题&quot; class=&quot;headerlink&quot; title=&quot;一、安装主题&quot;&gt;&lt;/a&gt;一、安装主题&lt;/h2&gt;&lt;p&gt;我选的是&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS上使用Hexo+github搭建自己的博客</title>
    <link href="http://yoursite.com/2018/03/25/Mac%20OS%E4%B8%8A%E4%BD%BF%E7%94%A8Hexo+github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/03/25/Mac OS上使用Hexo+github搭建自己的博客/</id>
    <published>2018-03-25T14:35:17.000Z</published>
    <updated>2018-03-26T01:55:19.007Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前就想搭建一个个人博客了，之前在公司实习的时候用过Jekyll搭建一个”播客”，最近找实习，偶尔看到东西会做点笔记，所以想着自己搭建一个个人博客，Jekyll其实和Hexo类似，都可以用来搭建播客，目前看到关于Hexo的资源比较多，所以决定使用Hexo来搭建。用下来个人觉得Hexo确实会比jekyll好用很多。作为一个年少无为，买不起服务器，买不起域名的穷low程序媛，就想着使用Hexo搭建一个个人博客，并关联到GitHub上，节省域名费用。欢迎大家在评论区留言，带我装逼带我飞。<br><a id="more"></a><br>PS:因本人用的是苹果机，所以本教程以MACOS为参考，但mac与windows搭建的方法步骤其实相差无几。主要参考文章<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></p><h1 id="相关步骤"><a href="#相关步骤" class="headerlink" title="相关步骤"></a>相关步骤</h1><h3 id="1、安装node-js和配置好node-js环境，这里不详细说，推荐使用homebrew安装。请参考node-js在mac上环境安装与测试-成功界面如下："><a href="#1、安装node-js和配置好node-js环境，这里不详细说，推荐使用homebrew安装。请参考node-js在mac上环境安装与测试-成功界面如下：" class="headerlink" title="1、安装node.js和配置好node.js环境，这里不详细说，推荐使用homebrew安装。请参考node.js在mac上环境安装与测试.成功界面如下："></a>1、安装node.js和配置好node.js环境，这里不详细说，推荐使用homebrew安装。请参考<a href="http://blog.csdn.net/mr_liu_easy_ios/article/details/53815413" target="_blank" rel="noopener">node.js在mac上环境安装与测试</a>.成功界面如下：</h3><p><img src="/images/hexo/hexo01.png" alt="Alt text"></p><hr><h3 id="2、安装git和配置好git环境，这里我也是用homebrew直接安装的。成功界面如下："><a href="#2、安装git和配置好git环境，这里我也是用homebrew直接安装的。成功界面如下：" class="headerlink" title="2、安装git和配置好git环境，这里我也是用homebrew直接安装的。成功界面如下："></a>2、安装git和配置好git环境，这里我也是用homebrew直接安装的。成功界面如下：</h3><p><img src="/images/hexo/hexo02.png" alt="Alt text"></p><hr><h3 id="3、安装Hexo，在自己认为合适的地方创一个新文件夹，用来保存博客的相关项目代码。"><a href="#3、安装Hexo，在自己认为合适的地方创一个新文件夹，用来保存博客的相关项目代码。" class="headerlink" title="3、安装Hexo，在自己认为合适的地方创一个新文件夹，用来保存博客的相关项目代码。"></a>3、安装Hexo，在自己认为合适的地方创一个新文件夹，用来保存博客的相关项目代码。</h3><p>输入<code>npm install hexo –g</code>,开始安装Hexo。（我这样直接安装的时候发生了个错误，提示没有权限，所以我在前面又加了一个sudo）。<br><img src="/images/hexo/hexo03.png" alt="Alt text"><br>输入<code>hexo-v</code>，检查hexo是否安装成功。<br><img src="/images/hexo/hexo04.png" alt="Alt text"><br>输入<code>hexo init</code>，初始化该文件<br><img src="/images/hexo/hexo05.png" alt="Alt text"><br><img src="/images/hexo/hexo06.png" alt="Alt text"><br>看到Start blogging with Hexo！初始化完成！<br>输入<code>npm install</code> ，安装所需要的组件。<br><img src="/images/hexo/hexo07.png" alt="Alt text"><br>输入<code>hexo g</code> ，首次体验hexo。<br><img src="/images/hexo/hexo08.png" alt="Alt text"><br>输入<code>hexo s</code> ,开启服务器，访问该网址，正式体验hexo（加入页面一直无法跳转，那么端口可能被占用了，此时我们ctrl+c停止服务器，接着输入”<code>hexo server –p 端口号</code>”来改变端口号）<br>出现下图就成功了！<br><img src="/images/hexo/hexo09.png" alt="Alt text"></p><hr><h3 id="4、Github账户注册和新建项目"><a href="#4、Github账户注册和新建项目" class="headerlink" title="4、Github账户注册和新建项目"></a>4、Github账户注册和新建项目</h3><p><strong>项目必须要遵守格式：账户名.github.io</strong>，不然接下来会有很多麻烦。并且需要勾选<strong>Initialize this repository with a README</strong>。(这里我第一次的时候账户名写错了，导致后来本地的样式和github显示的不一致，后来我将下图中的myBlog改为我的账户名liuqian0413就显示正常了。<strong>大家记住一定不要写错了！</strong>)<br><img src="/images/hexo/hexo10.png" alt="Alt text"><br>在建立好的项目右上方有个setting按钮，点击，向下拉到Github Pages，你会看到该项目已经被部署到网络上，能够用外网来访问它。（如果没有出现地址，将souce那一栏的第一个参数选为master branch，然后点击save后就会刷新出来）<br><img src="/images/hexo/hexo11.jpeg" alt="Alt text"></p><hr><h3 id="5、将Hexo与Github-Page联系起来"><a href="#5、将Hexo与Github-Page联系起来" class="headerlink" title="5、将Hexo与Github Page联系起来"></a>5、将Hexo与Github Page联系起来</h3><p>输入<code>cd ~/.ssh</code>，检查是否有.ssh的文件夹<br><img src="/images/hexo/hexo12.png" alt="Alt text"></p><p>输入<code>ls</code>，列出该文件下的内容。下图说明存在<br><img src="/images/hexo/hexo13.png" alt="Alt text"></p><p>如果没有找到该文件，输入<code>ssh-keygen -t rsa -C &quot;784575932@.com &quot;</code>（这里的邮箱填写你注册GitHub时候自己的邮箱）,连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub<br><img src="/images/hexo/hexo14.png" alt="Alt text"></p><p>接着输入<code>eval &quot;$(ssh-agent -s)&quot;</code>，添加密钥到ssh-agent<br><img src="/images/hexo/hexo15.png" alt="Alt text"></p><p>再输入<code>ssh-add ~/.ssh/id_rsa</code>，添加生成的SSH key到ssh-agent.<br><img src="/images/hexo/hexo16.png" alt="Alt text"><br><img src="/images/hexo/hexo18.png" alt="Alt text"></p><p>接着登录Github，点击头像下的settings，添加ssh<br><img src="/images/hexo/hexo17.png" alt="Alt text"></p><p>复制id_rsa.pub文件里面的内容，我们可以使用<code>vim id_rsa.pub</code>查看<br><img src="/images/hexo/hexo21.png" alt="Alt text"></p><p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去<br><img src="/images/hexo/hexo19.png" alt="Alt text"><br><img src="/images/hexo/hexo20.png" alt="Alt text"></p><p>输入<code>ssh -T git@github.com</code>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了<br><img src="/images/hexo/hexo22.png" alt="Alt text"></p><blockquote><p>问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决<br>首先，清除所有的key-pair:<br><code>ssh-add -D</code><br><code>rm -r ~/.ssh</code><br>删除你在GitHub中的public-key<br>重新生成ssh密钥对<br><code>ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;</code><br>接下来正常操作：<br>在GitHub上添加公钥public-key:<br>1.首先在你的终端运行<code>xclip -sel c ~/.ssh/id_rsa.pub</code>将公钥内容复制到剪切板<br>2.在github上添加公钥时，直接复制即可<br>3.保存<br>测试：<br>在终端<code>ssh -T git@github.com</code></p></blockquote><p>配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）<br><img src="/images/hexo/hexo23.png" alt="Alt text"></p><p>repo值是你在github项目里的ssh(右下角)<br><img src="/images/hexo/hexo24.png" alt="Alt text"></p><hr><h3 id="6、新建博客并发布"><a href="#6、新建博客并发布" class="headerlink" title="6、新建博客并发布"></a>6、新建博客并发布</h3><p>新建一篇博客，在cmd执行命令：hexo new post “博客名”<br><img src="/images/hexo/hexo25.png" alt="Alt text"></p><p>这时候在文件夹_posts目录下将会看到已经创建的文件:<br><img src="/images/hexo/hexo26.png" alt="Alt text"></p><p>在生成以及部署文章之前，需要安装一个扩展：<code>npm install hexo-deployer-git --save</code><br><img src="/images/hexo/hexo27.png" alt="Alt text"></p><p>使用编辑器编好文章，那么就可以使用命令：<code>hexo d -g</code>，生成以及部署了<br><img src="/images/hexo/hexo28.png" alt="Alt text"></p><p>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章<br><img src="/images/hexo/hexo29.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久以前就想搭建一个个人博客了，之前在公司实习的时候用过Jekyll搭建一个”播客”，最近找实习，偶尔看到东西会做点笔记，所以想着自己搭建一个个人博客，Jekyll其实和Hexo类似，都可以用来搭建播客，目前看到关于Hexo的资源比较多，所以决定使用Hexo来搭建。用下来个人觉得Hexo确实会比jekyll好用很多。作为一个年少无为，买不起服务器，买不起域名的穷low程序媛，就想着使用Hexo搭建一个个人博客，并关联到GitHub上，节省域名费用。欢迎大家在评论区留言，带我装逼带我飞。&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/03/25/hello-world/"/>
    <id>http://yoursite.com/2018/03/25/hello-world/</id>
    <published>2018-03-25T13:13:48.372Z</published>
    <updated>2018-03-25T13:13:48.372Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
